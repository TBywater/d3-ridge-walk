import {
  flip
} from "./chunk-Y7IT4U7L.js";
import "./chunk-XOEY4QA3.js";
import "./chunk-WF55E4KL.js";
import "./chunk-2AR2JWS2.js";
import {
  writable
} from "./chunk-7SMVAJDB.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  createEventDispatcher,
  create_animation,
  create_component,
  create_slot,
  destroy_block,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  fix_and_destroy_block,
  fix_position,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_svelte_dataset,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  prevent_default,
  prop_dev,
  run_all,
  safe_not_equal,
  set_data_dev,
  set_input_value,
  space,
  svg_element,
  text,
  tick,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots
} from "./chunk-UT2HSVSI.js";
import "./chunk-XSCOKBUT.js";
import "./chunk-F3FYYIAV.js";

// node_modules/.pnpm/svelecte@4.0.1_svelte@4.2.15/node_modules/svelecte/dist/utils/sifter.js
var Sifter = function(items, settings2) {
  this.items = items;
  this.settings = settings2 || { diacritics: true };
};
Sifter.prototype.tokenize = function(query, respect_word_boundaries) {
  query = trim(String(query || "").toLowerCase());
  if (!query || !query.length)
    return [];
  var i, n, regex, letter;
  var tokens = [];
  var words = query.split(/ +/);
  for (i = 0, n = words.length; i < n; i++) {
    regex = escape_regex(words[i]);
    if (this.settings.diacritics) {
      for (letter in DIACRITICS) {
        if (DIACRITICS.hasOwnProperty(letter)) {
          regex = regex.replace(new RegExp(letter, "g"), DIACRITICS[letter]);
        }
      }
    }
    if (respect_word_boundaries)
      regex = "\\b" + regex;
    tokens.push({
      string: words[i],
      regex: new RegExp(regex, "i")
    });
  }
  return tokens;
};
Sifter.prototype.iterator = function(object, callback) {
  var iterator;
  if (Array.isArray(object)) {
    iterator = Array.prototype.forEach || function(callback2) {
      for (var i = 0, n = this.length; i < n; i++) {
        callback2(this[i], i, this);
      }
    };
  } else {
    iterator = function(callback2) {
      for (var key in this) {
        if (this.hasOwnProperty(key)) {
          callback2(this[key], key, this);
        }
      }
    };
  }
  iterator.apply(object, [callback]);
};
Sifter.prototype.getScoreFunction = function(search, options) {
  var self, fields, tokens, token_count, nesting;
  self = this;
  search = self.prepareSearch(search, options);
  tokens = search.tokens;
  fields = search.options.fields;
  token_count = tokens.length;
  nesting = search.options.nesting;
  var scoreValue = function(value, token) {
    var score, pos;
    if (!value)
      return 0;
    value = String(value || "");
    pos = value.search(token.regex);
    if (pos === -1)
      return 0;
    score = token.string.length / value.length;
    if (pos === 0)
      score += 0.5;
    return score;
  };
  var scoreObject = function() {
    var field_count = fields.length;
    if (!field_count) {
      return function() {
        return 0;
      };
    }
    if (field_count === 1) {
      return function(token, data) {
        return scoreValue(getattr(data, fields[0], nesting), token);
      };
    }
    return function(token, data) {
      for (var i = 0, sum = 0; i < field_count; i++) {
        sum += scoreValue(getattr(data, fields[i], nesting), token);
      }
      return sum / field_count;
    };
  }();
  if (!token_count) {
    return function() {
      return 0;
    };
  }
  if (token_count === 1) {
    return function(data) {
      return scoreObject(tokens[0], data);
    };
  }
  if (search.options.conjunction === "and") {
    return function(data) {
      var score;
      for (var i = 0, sum = 0; i < token_count; i++) {
        score = scoreObject(tokens[i], data);
        if (score <= 0)
          return 0;
        sum += score;
      }
      return sum / token_count;
    };
  } else {
    return function(data) {
      for (var i = 0, sum = 0; i < token_count; i++) {
        sum += scoreObject(tokens[i], data);
      }
      return sum / token_count;
    };
  }
};
Sifter.prototype.getSortFunction = function(search, options) {
  var i, n, self, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;
  self = this;
  search = self.prepareSearch(search, options);
  sort = !search.query && options.sort_empty || options.sort;
  get_field = function(name, result) {
    if (name === "$score")
      return result.score;
    return getattr(self.items[result.id], name, options.nesting);
  };
  fields = [];
  if (sort) {
    for (i = 0, n = sort.length; i < n; i++) {
      if (search.query || sort[i].field !== "$score") {
        fields.push(sort[i]);
      }
    }
  }
  if (search.query) {
    implicit_score = true;
    for (i = 0, n = fields.length; i < n; i++) {
      if (fields[i].field === "$score") {
        implicit_score = false;
        break;
      }
    }
    if (implicit_score) {
      fields.unshift({ field: "$score", direction: "desc" });
    }
  } else {
    for (i = 0, n = fields.length; i < n; i++) {
      if (fields[i].field === "$score") {
        fields.splice(i, 1);
        break;
      }
    }
  }
  multipliers = [];
  for (i = 0, n = fields.length; i < n; i++) {
    multipliers.push(fields[i].direction === "desc" ? -1 : 1);
  }
  fields_count = fields.length;
  if (!fields_count) {
    return null;
  } else if (fields_count === 1) {
    field = fields[0].field;
    multiplier = multipliers[0];
    return function(a, b) {
      return multiplier * cmp(
        get_field(field, a),
        get_field(field, b)
      );
    };
  } else {
    return function(a, b) {
      var i2, result, a_value, b_value, field2;
      for (i2 = 0; i2 < fields_count; i2++) {
        field2 = fields[i2].field;
        result = multipliers[i2] * cmp(
          get_field(field2, a),
          get_field(field2, b)
        );
        if (result)
          return result;
      }
      return 0;
    };
  }
};
Sifter.prototype.prepareSearch = function(query, options) {
  if (typeof query === "object")
    return query;
  options = extend({}, options);
  var option_fields = options.fields;
  var option_sort = options.sort;
  var option_sort_empty = options.sort_empty;
  if (option_fields && !Array.isArray(option_fields))
    options.fields = [option_fields];
  if (option_sort && !Array.isArray(option_sort))
    options.sort = [option_sort];
  if (option_sort_empty && !Array.isArray(option_sort_empty))
    options.sort_empty = [option_sort_empty];
  return {
    options,
    query: String(query || "").toLowerCase(),
    tokens: this.tokenize(query, options.respect_word_boundaries),
    total: 0,
    items: []
  };
};
Sifter.prototype.search = function(query, options) {
  var self = this, value, score, search, calculateScore;
  var fn_sort;
  var fn_score;
  search = this.prepareSearch(query, options);
  options = search.options;
  query = search.query;
  fn_score = options.score || self.getScoreFunction(search);
  if (query.length) {
    self.iterator(self.items, function(item, id) {
      score = fn_score(item);
      if (options.filter === false || score > 0) {
        search.items.push({ "score": score, "id": id });
      }
    });
  } else {
    self.iterator(self.items, function(item, id) {
      search.items.push({ "score": 1, "id": id });
    });
  }
  fn_sort = self.getSortFunction(search, options);
  if (fn_sort)
    search.items.sort(fn_sort);
  search.total = search.items.length;
  if (typeof options.limit === "number") {
    search.items = search.items.slice(0, options.limit);
  }
  return search;
};
var cmp = function(a, b) {
  if (typeof a === "number" && typeof b === "number") {
    return a > b ? 1 : a < b ? -1 : 0;
  }
  a = asciifold(String(a || ""));
  b = asciifold(String(b || ""));
  if (a > b)
    return 1;
  if (b > a)
    return -1;
  return 0;
};
var extend = function(a, b) {
  var i, n, k, object;
  for (i = 1, n = arguments.length; i < n; i++) {
    object = arguments[i];
    if (!object)
      continue;
    for (k in object) {
      if (object.hasOwnProperty(k)) {
        a[k] = object[k];
      }
    }
  }
  return a;
};
var getattr = function(obj, name, nesting) {
  if (!obj || !name)
    return;
  if (!nesting)
    return obj[name];
  var names = name.split(".");
  while (names.length && (obj = obj[names.shift()]))
    ;
  return obj;
};
var trim = function(str) {
  return (str + "").replace(/^\s+|\s+$|/g, "");
};
var escape_regex = function(str) {
  return (str + "").replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
};
var DIACRITICS = {
  "a": "[aá¸€á¸Ä‚ÄƒÃ‚Ã¢ÇÇŽÈºâ±¥È¦È§áº áº¡Ã„Ã¤Ã€Ã ÃÃ¡Ä€ÄÃƒÃ£Ã…Ã¥Ä…Ä„ÃƒÄ…Ä„]",
  "b": "[bâ¢Î²Î’Bà¸¿ðŒá›’]",
  "c": "[cÄ†Ä‡ÄˆÄ‰ÄŒÄÄŠÄ‹CÌ„cÌ„Ã‡Ã§á¸ˆá¸‰È»È¼Æ‡ÆˆÉ•á´„ï¼£ï½ƒ]",
  "d": "[dÄŽÄá¸Šá¸‹á¸á¸‘á¸Œá¸á¸’á¸“á¸Žá¸ÄÄ‘DÌ¦dÌ¦Æ‰É–ÆŠÉ—Æ‹ÆŒáµ­á¶á¶‘È¡á´…ï¼¤ï½„Ã°]",
  "e": "[eÃ‰Ã©ÃˆÃ¨ÃŠÃªá¸˜á¸™ÄšÄ›Ä”Ä•áº¼áº½á¸šá¸›áººáº»Ä–Ä—Ã‹Ã«Ä’Ä“È¨È©Ä˜Ä™á¶’É†É‡È„È…áº¾áº¿á»€á»á»„á»…á»‚á»ƒá¸œá¸á¸–á¸—á¸”á¸•È†È‡áº¸áº¹á»†á»‡â±¸á´‡ï¼¥ï½…É˜ÇÆÆÎµ]",
  "f": "[fÆ‘Æ’á¸žá¸Ÿ]",
  "g": "[gÉ¢â‚²Ç¤Ç¥ÄœÄÄžÄŸÄ¢Ä£Æ“É Ä Ä¡]",
  "h": "[hÄ¤Ä¥Ä¦Ä§á¸¨á¸©áº–áº–á¸¤á¸¥á¸¢á¸£É¦Ê°Ç¶Æ•]",
  "i": "[iÃÃ­ÃŒÃ¬Ä¬Ä­ÃŽÃ®ÇÇÃÃ¯á¸®á¸¯Ä¨Ä©Ä®Ä¯ÄªÄ«á»ˆá»‰ÈˆÈ‰ÈŠÈ‹á»Šá»‹á¸¬á¸­Æ—É¨É¨Ì†áµ»á¶–Ä°iIÄ±Éªï¼©ï½‰]",
  "j": "[jÈ·Ä´ÄµÉˆÉ‰ÊÉŸÊ²]",
  "k": "[kÆ˜Æ™ê€êá¸°á¸±Ç¨Ç©á¸²á¸³á¸´á¸µÎºÏ°â‚­]",
  "l": "[lÅÅ‚Ä½Ä¾Ä»Ä¼Ä¹Äºá¸¶á¸·á¸¸á¸¹á¸¼á¸½á¸ºá¸»Ä¿Å€È½Æšâ± â±¡â±¢É«É¬á¶…É­È´ÊŸï¼¬ï½Œ]",
  "n": "[nÅƒÅ„Ç¸Ç¹Å‡ÅˆÃ‘Ã±á¹„á¹…Å…Å†á¹†á¹‡á¹Šá¹‹á¹ˆá¹‰NÌˆnÌˆÆÉ²È Æžáµ°á¶‡É³ÈµÉ´ï¼®ï½ŽÅŠÅ‹]",
  "o": "[oÃ˜Ã¸Ã–Ã¶Ã“Ã³Ã’Ã²Ã”Ã´Ç‘Ç’ÅÅ‘ÅŽÅÈ®È¯á»Œá»ÆŸÉµÆ Æ¡á»Žá»ÅŒÅÃ•ÃµÇªÇ«ÈŒÈÕ•Ö…]",
  "p": "[pá¹”á¹•á¹–á¹—â±£áµ½Æ¤Æ¥áµ±]",
  "q": "[qê–ê—Ê ÉŠÉ‹ê˜ê™qÌƒ]",
  "r": "[rÅ”Å•ÉŒÉÅ˜Å™Å–Å—á¹˜á¹™ÈÈ‘È’È“á¹šá¹›â±¤É½]",
  "s": "[sÅšÅ›á¹ á¹¡á¹¢á¹£êž¨êž©ÅœÅÅ Å¡ÅžÅŸÈ˜È™SÌˆsÌˆ]",
  "t": "[tÅ¤Å¥á¹ªá¹«Å¢Å£á¹¬á¹­Æ®ÊˆÈšÈ›á¹°á¹±á¹®á¹¯Æ¬Æ­]",
  "u": "[uÅ¬Å­É„Ê‰á»¤á»¥ÃœÃ¼ÃšÃºÃ™Ã¹Ã›Ã»Ç“Ç”Å°Å±Å¬Å­Æ¯Æ°á»¦á»§ÅªÅ«Å¨Å©Å²Å³È”È•âˆª]",
  "v": "[vá¹¼á¹½á¹¾á¹¿Æ²Ê‹êžêŸâ±±Ê‹]",
  "w": "[wáº‚áºƒáº€áºÅ´Åµáº„áº…áº†áº‡áºˆáº‰]",
  "x": "[xáºŒáºáºŠáº‹Ï‡]",
  "y": "[yÃÃ½á»²á»³Å¶Å·Å¸Ã¿á»¸á»¹áºŽáºá»´á»µÉŽÉÆ³Æ´]",
  "z": "[zÅ¹Åºáºáº‘Å½Å¾Å»Å¼áº’áº“áº”áº•ÆµÆ¶]"
};
var asciifold = function() {
  var i, n, k, chunk;
  var foreignletters = "";
  var lookup = {};
  for (k in DIACRITICS) {
    if (DIACRITICS.hasOwnProperty(k)) {
      chunk = DIACRITICS[k].substring(2, DIACRITICS[k].length - 1);
      foreignletters += chunk;
      for (i = 0, n = chunk.length; i < n; i++) {
        lookup[chunk.charAt(i)] = k;
      }
    }
  }
  var regexp = new RegExp("[" + foreignletters + "]", "g");
  return function(str) {
    return str.replace(regexp, function(foreignletter) {
      return lookup[foreignletter];
    }).toLowerCase();
  };
}();
var sifter_default = Sifter;

// node_modules/.pnpm/svelecte@4.0.1_svelte@4.2.15/node_modules/svelecte/dist/utils/helpers.js
var itemHtml;
function highlightSearch(item, renderInSelection, inputValue, itemRenderer, disableHighlight) {
  const itemHtmlText = itemRenderer(item, renderInSelection, inputValue);
  if (inputValue == "" || item.isSelected || disableHighlight) {
    return itemHtmlText;
  }
  if (!itemHtml) {
    itemHtml = document.createElement("div");
  }
  itemHtml.innerHTML = itemHtmlText;
  const pattern = asciifold(inputValue);
  (pattern.includes("|") ? pattern.split("|").map((w) => w.trim()) : pattern.split(" ")).filter((e) => e).forEach((pat) => {
    highlight(itemHtml, pat);
  });
  return itemHtml.innerHTML;
}
var highlight = function(node, regex) {
  let skip = 0;
  if (node.nodeType === 3) {
    const folded = asciifold(node.data);
    let pos = folded.indexOf(regex);
    pos -= folded.substr(0, pos).toUpperCase().length - folded.substr(0, pos).length;
    if (pos >= 0) {
      const spannode = document.createElement("span");
      spannode.className = "highlight";
      const middlebit = node.splitText(pos);
      const endbit = middlebit.splitText(regex.length);
      const middleclone = middlebit.cloneNode(true);
      spannode.appendChild(middleclone);
      middlebit.parentNode.replaceChild(spannode, middlebit);
      skip = 1;
    }
  } else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== "highlight" || node.tagName !== "SPAN")) {
    for (var i = 0; i < node.childNodes.length; ++i) {
      i += highlight(node.childNodes[i], regex);
    }
  }
  return skip;
};
function iOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function android() {
  return navigator.userAgent.toLowerCase().includes("android");
}
function onCreate_helper(enteredValue) {
  return (enteredValue || "").replace(/\t/g, " ").trim().split(" ").filter((ch) => ch).join(" ");
}
function escapeHtml(html) {
  return `${html}`.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}

// node_modules/.pnpm/svelecte@4.0.1_svelte@4.2.15/node_modules/svelecte/dist/utils/fetch.js
function debounce(fn, delay) {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}
function requestFactory(query, { url, parentValue, initial }, fetchProps) {
  if (parentValue) {
    url = url.replace("[parent]", encodeURIComponent(parentValue));
  }
  if (query) {
    url = url.replace("[query]", encodeURIComponent(query));
  }
  if (Array.isArray(initial) && initial.length === 0)
    initial = null;
  if (initial) {
    url = url.replace("[query]", "init");
  }
  const fetchUrl = url[0] === "/" ? new URL(url, window.location.origin) : new URL(url);
  if (initial) {
    const arr = Array.isArray(initial) ? initial : [initial];
    fetchUrl.searchParams.append("init", arr.join(","));
  }
  const controller = new AbortController();
  const props = Object.assign({}, {
    headers: {
      "X-Requested-With": "XMLHttpRequest"
    },
    cache: "no-store"
  }, fetchProps, { signal: controller.signal });
  return {
    request: new Request(fetchUrl, props),
    controller
  };
}

// node_modules/.pnpm/svelecte@4.0.1_svelte@4.2.15/node_modules/svelecte/dist/settings.js
var settings = {
  // basic
  valueField: null,
  labelField: null,
  groupLabelField: "label",
  groupItemsField: "options",
  disabledField: "$disabled",
  placeholder: "Select",
  valueAsObject: false,
  // ui
  searchable: true,
  clearable: false,
  highlightFirstItem: true,
  selectOnTab: false,
  resetOnBlur: true,
  resetOnSelect: true,
  fetchResetOnBlur: true,
  fetchDebounceTime: 300,
  // multi
  multiple: false,
  closeAfterSelect: "auto",
  max: 0,
  collapseSelection: null,
  keepSelectionInList: "auto",
  // create
  creatable: false,
  creatablePrefix: "*",
  keepCreated: true,
  allowEditing: false,
  delimiter: ",",
  // remote
  fetchCallback: null,
  minQuery: 1,
  // performance
  lazyDropdown: true,
  // virtual list
  virtualList: false,
  vlItemSize: null,
  vlHeight: null,
  // i18n
  i18n: {
    aria_label: "",
    aria_describedby: "",
    aria_selected: (opts) => opts.length ? `Option${opts.length > 1 ? "s" : ""} ${opts.join(", ")} selected.` : "",
    aria_listActive: (opt, labelField, count) => `You are currently focused on option ${opt[labelField]}. ${count} result${count > 1 ? "s" : ""} available.`,
    aria_inputFocused: () => "Select is focused, type to refine list, press down to scroll through the list",
    empty: "No options",
    nomatch: "No matching options",
    max: (num) => `Maximum items ${num} selected`,
    fetchBefore: "Type to start searching",
    fetchQuery: (minQuery, inputLength) => `Type at least ${minQuery} character${minQuery > 1 ? "s" : ""} to start searching`,
    fetchInit: "Fetching data, please wait...",
    fetchEmpty: "No data related to your search",
    collapsedSelection: (count) => `${count} selected`,
    createRowLabel: (value) => `Add '${value}'`,
    emptyCreatable: "Add new by typing"
  },
  requestFactory: null
};
var settings_default = settings;

// node_modules/.pnpm/svelte-tiny-virtual-list@2.0.5/node_modules/svelte-tiny-virtual-list/src/constants.js
var ALIGNMENT = {
  AUTO: "auto",
  START: "start",
  CENTER: "center",
  END: "end"
};
var DIRECTION = {
  HORIZONTAL: "horizontal",
  VERTICAL: "vertical"
};
var SCROLL_CHANGE_REASON = {
  OBSERVED: 0,
  REQUESTED: 1
};
var SCROLL_PROP = {
  [DIRECTION.VERTICAL]: "top",
  [DIRECTION.HORIZONTAL]: "left"
};
var SCROLL_PROP_LEGACY = {
  [DIRECTION.VERTICAL]: "scrollTop",
  [DIRECTION.HORIZONTAL]: "scrollLeft"
};

// node_modules/.pnpm/svelte-tiny-virtual-list@2.0.5/node_modules/svelte-tiny-virtual-list/src/SizeAndPositionManager.js
var SizeAndPositionManager = class {
  /**
   * @param {Options} options
   */
  constructor({ itemSize, itemCount, estimatedItemSize }) {
    this.itemSize = itemSize;
    this.itemCount = itemCount;
    this.estimatedItemSize = estimatedItemSize;
    this.itemSizeAndPositionData = {};
    this.lastMeasuredIndex = -1;
    this.checkForMismatchItemSizeAndItemCount();
    if (!this.justInTime)
      this.computeTotalSizeAndPositionData();
  }
  get justInTime() {
    return typeof this.itemSize === "function";
  }
  /**
   * @param {Options} options
   */
  updateConfig({ itemSize, itemCount, estimatedItemSize }) {
    if (itemCount != null) {
      this.itemCount = itemCount;
    }
    if (estimatedItemSize != null) {
      this.estimatedItemSize = estimatedItemSize;
    }
    if (itemSize != null) {
      this.itemSize = itemSize;
    }
    this.checkForMismatchItemSizeAndItemCount();
    if (this.justInTime && this.totalSize != null) {
      this.totalSize = void 0;
    } else {
      this.computeTotalSizeAndPositionData();
    }
  }
  checkForMismatchItemSizeAndItemCount() {
    if (Array.isArray(this.itemSize) && this.itemSize.length < this.itemCount) {
      throw Error(
        `When itemSize is an array, itemSize.length can't be smaller than itemCount`
      );
    }
  }
  /**
   * @param {number} index
   */
  getSize(index) {
    const { itemSize } = this;
    if (typeof itemSize === "function") {
      return itemSize(index);
    }
    return Array.isArray(itemSize) ? itemSize[index] : itemSize;
  }
  /**
   * Compute the totalSize and itemSizeAndPositionData at the start,
   * only when itemSize is a number or an array.
   */
  computeTotalSizeAndPositionData() {
    let totalSize = 0;
    for (let i = 0; i < this.itemCount; i++) {
      const size = this.getSize(i);
      const offset = totalSize;
      totalSize += size;
      this.itemSizeAndPositionData[i] = {
        offset,
        size
      };
    }
    this.totalSize = totalSize;
  }
  getLastMeasuredIndex() {
    return this.lastMeasuredIndex;
  }
  /**
   * This method returns the size and position for the item at the specified index.
   *
   * @param {number} index
   */
  getSizeAndPositionForIndex(index) {
    if (index < 0 || index >= this.itemCount) {
      throw Error(
        `Requested index ${index} is outside of range 0..${this.itemCount}`
      );
    }
    return this.justInTime ? this.getJustInTimeSizeAndPositionForIndex(index) : this.itemSizeAndPositionData[index];
  }
  /**
   * This is used when itemSize is a function.
   * just-in-time calculates (or used cached values) for items leading up to the index.
   *
   * @param {number} index
   */
  getJustInTimeSizeAndPositionForIndex(index) {
    if (index > this.lastMeasuredIndex) {
      const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();
      let offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;
      for (let i = this.lastMeasuredIndex + 1; i <= index; i++) {
        const size = this.getSize(i);
        if (size == null || isNaN(size)) {
          throw Error(`Invalid size returned for index ${i} of value ${size}`);
        }
        this.itemSizeAndPositionData[i] = {
          offset,
          size
        };
        offset += size;
      }
      this.lastMeasuredIndex = index;
    }
    return this.itemSizeAndPositionData[index];
  }
  getSizeAndPositionOfLastMeasuredItem() {
    return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : { offset: 0, size: 0 };
  }
  /**
   * Total size of all items being measured.
   *
   * @return {number}
   */
  getTotalSize() {
    if (this.totalSize)
      return this.totalSize;
    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();
    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;
  }
  /**
   * Determines a new offset that ensures a certain item is visible, given the alignment.
   *
   * @param {'auto' | 'start' | 'center' | 'end'} align Desired alignment within container
   * @param {number | undefined} containerSize Size (width or height) of the container viewport
   * @param {number | undefined} currentOffset
   * @param {number | undefined} targetIndex
   * @return {number} Offset to use to ensure the specified item is visible
   */
  getUpdatedOffsetForIndex({ align = ALIGNMENT.START, containerSize, currentOffset, targetIndex }) {
    if (containerSize <= 0) {
      return 0;
    }
    const datum = this.getSizeAndPositionForIndex(targetIndex);
    const maxOffset = datum.offset;
    const minOffset = maxOffset - containerSize + datum.size;
    let idealOffset;
    switch (align) {
      case ALIGNMENT.END:
        idealOffset = minOffset;
        break;
      case ALIGNMENT.CENTER:
        idealOffset = maxOffset - (containerSize - datum.size) / 2;
        break;
      case ALIGNMENT.START:
        idealOffset = maxOffset;
        break;
      default:
        idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
    }
    const totalSize = this.getTotalSize();
    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
  }
  /**
   * @param {number} containerSize
   * @param {number} offset
   * @param {number} overscanCount
   * @return {{stop: number|undefined, start: number|undefined}}
   */
  getVisibleRange({ containerSize = 0, offset, overscanCount }) {
    const totalSize = this.getTotalSize();
    if (totalSize === 0) {
      return {};
    }
    const maxOffset = offset + containerSize;
    let start = this.findNearestItem(offset);
    if (start === void 0) {
      throw Error(`Invalid offset ${offset} specified`);
    }
    const datum = this.getSizeAndPositionForIndex(start);
    offset = datum.offset + datum.size;
    let stop = start;
    while (offset < maxOffset && stop < this.itemCount - 1) {
      stop++;
      offset += this.getSizeAndPositionForIndex(stop).size;
    }
    if (overscanCount) {
      start = Math.max(0, start - overscanCount);
      stop = Math.min(stop + overscanCount, this.itemCount - 1);
    }
    return {
      start,
      stop
    };
  }
  /**
   * Clear all cached values for items after the specified index.
   * This method should be called for any item that has changed its size.
   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.
   *
   * @param {number} index
   */
  resetItem(index) {
    this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);
  }
  /**
   * Searches for the item (index) nearest the specified offset.
   *
   * If no exact match is found the next lowest item index will be returned.
   * This allows partially visible items (with offsets just before/above the fold) to be visible.
   *
   * @param {number} offset
   */
  findNearestItem(offset) {
    if (isNaN(offset)) {
      throw Error(`Invalid offset ${offset} specified`);
    }
    offset = Math.max(0, offset);
    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();
    const lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);
    if (lastMeasuredSizeAndPosition.offset >= offset) {
      return this.binarySearch({
        high: lastMeasuredIndex,
        low: 0,
        offset
      });
    } else {
      return this.exponentialSearch({
        index: lastMeasuredIndex,
        offset
      });
    }
  }
  /**
   * @private
   * @param {number} low
   * @param {number} high
   * @param {number} offset
   */
  binarySearch({ low, high, offset }) {
    let middle = 0;
    let currentOffset = 0;
    while (low <= high) {
      middle = low + Math.floor((high - low) / 2);
      currentOffset = this.getSizeAndPositionForIndex(middle).offset;
      if (currentOffset === offset) {
        return middle;
      } else if (currentOffset < offset) {
        low = middle + 1;
      } else if (currentOffset > offset) {
        high = middle - 1;
      }
    }
    if (low > 0) {
      return low - 1;
    }
    return 0;
  }
  /**
   * @private
   * @param {number} index
   * @param {number} offset
   */
  exponentialSearch({ index, offset }) {
    let interval = 1;
    while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {
      index += interval;
      interval *= 2;
    }
    return this.binarySearch({
      high: Math.min(index, this.itemCount - 1),
      low: Math.floor(index / 2),
      offset
    });
  }
};

// node_modules/.pnpm/svelte-tiny-virtual-list@2.0.5/node_modules/svelte-tiny-virtual-list/src/VirtualList.svelte
var { Object: Object_1 } = globals;
var file = "node_modules/.pnpm/svelte-tiny-virtual-list@2.0.5/node_modules/svelte-tiny-virtual-list/src/VirtualList.svelte";
function add_css(target) {
  append_styles(target, "svelte-dwpad5", ".virtual-list-wrapper.svelte-dwpad5{overflow:auto;will-change:transform;-webkit-overflow-scrolling:touch}.virtual-list-inner.svelte-dwpad5{position:relative;display:flex;width:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlydHVhbExpc3Quc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW1WQyxtQ0FBc0IsQ0FDckIsUUFBUSxDQUFvQixJQUFJLENBQ2hDLFdBQVcsQ0FBaUIsU0FBUyxDQUNyQywwQkFBMEIsQ0FBRSxLQUM3QixDQUVBLGlDQUFvQixDQUNuQixRQUFRLENBQUksUUFBUSxDQUNwQixPQUFPLENBQUssSUFBSSxDQUNoQixLQUFLLENBQU8sSUFDYiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiVmlydHVhbExpc3Quc3ZlbHRlIl19 */");
}
var get_footer_slot_changes = (dirty) => ({});
var get_footer_slot_context = (ctx) => ({});
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  return child_ctx;
}
var get_item_slot_changes = (dirty) => ({
  style: dirty[0] & /*items*/
  4,
  index: dirty[0] & /*items*/
  4
});
var get_item_slot_context = (ctx) => ({
  style: (
    /*item*/
    ctx[37].style
  ),
  index: (
    /*item*/
    ctx[37].index
  )
});
var get_header_slot_changes = (dirty) => ({});
var get_header_slot_context = (ctx) => ({});
function create_each_block(key_1, ctx) {
  let first;
  let current;
  const item_slot_template = (
    /*#slots*/
    ctx[21].item
  );
  const item_slot = create_slot(
    item_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_item_slot_context
  );
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      if (item_slot)
        item_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (item_slot)
        item_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (item_slot) {
        item_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (item_slot) {
        if (item_slot.p && (!current || dirty[0] & /*$$scope, items*/
        1048580)) {
          update_slot_base(
            item_slot,
            item_slot_template,
            ctx,
            /*$$scope*/
            ctx[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[20]
            ) : get_slot_changes(
              item_slot_template,
              /*$$scope*/
              ctx[20],
              dirty,
              get_item_slot_changes
            ),
            get_item_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(item_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      if (item_slot)
        item_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(331:2) {#each items as item (getKey ? getKey(item.index) : item.index)}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div1;
  let t0;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let current;
  const header_slot_template = (
    /*#slots*/
    ctx[21].header
  );
  const header_slot = create_slot(
    header_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_header_slot_context
  );
  let each_value = ensure_array_like_dev(
    /*items*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*getKey*/
    ctx2[0] ? (
      /*getKey*/
      ctx2[0](
        /*item*/
        ctx2[37].index
      )
    ) : (
      /*item*/
      ctx2[37].index
    )
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const footer_slot_template = (
    /*#slots*/
    ctx[21].footer
  );
  const footer_slot = create_slot(
    footer_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    get_footer_slot_context
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (header_slot)
        header_slot.c();
      t0 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (footer_slot)
        footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      if (header_slot)
        header_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      if (footer_slot)
        footer_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "virtual-list-inner svelte-dwpad5");
      attr_dev(
        div0,
        "style",
        /*innerStyle*/
        ctx[4]
      );
      add_location(div0, file, 329, 1, 7514);
      attr_dev(div1, "class", "virtual-list-wrapper svelte-dwpad5");
      attr_dev(
        div1,
        "style",
        /*wrapperStyle*/
        ctx[3]
      );
      add_location(div1, file, 326, 0, 7412);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (header_slot) {
        header_slot.m(div1, null);
      }
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append_hydration_dev(div1, t1);
      if (footer_slot) {
        footer_slot.m(div1, null);
      }
      ctx[22](div1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (header_slot) {
        if (header_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            header_slot,
            header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              header_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_header_slot_changes
            ),
            get_header_slot_context
          );
        }
      }
      if (dirty[0] & /*$$scope, items, getKey*/
      1048581) {
        each_value = ensure_array_like_dev(
          /*items*/
          ctx2[2]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block, null, get_each_context);
        check_outros();
      }
      if (!current || dirty[0] & /*innerStyle*/
      16) {
        attr_dev(
          div0,
          "style",
          /*innerStyle*/
          ctx2[4]
        );
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty[0] & /*$$scope*/
        1048576)) {
          update_slot_base(
            footer_slot,
            footer_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              footer_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              get_footer_slot_changes
            ),
            get_footer_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*wrapperStyle*/
      8) {
        attr_dev(
          div1,
          "style",
          /*wrapperStyle*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header_slot, local);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (header_slot)
        header_slot.d(detaching);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (footer_slot)
        footer_slot.d(detaching);
      ctx[22](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var thirdEventArg = (() => {
  let result = false;
  try {
    const arg = Object.defineProperty({}, "passive", {
      get() {
        result = { passive: true };
        return true;
      }
    });
    window.addEventListener("testpassive", arg, arg);
    window.remove("testpassive", arg, arg);
  } catch (e) {
  }
  return result;
})();
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("VirtualList", slots, ["header", "item", "footer"]);
  let { height } = $$props;
  let { width = "100%" } = $$props;
  let { itemCount } = $$props;
  let { itemSize } = $$props;
  let { estimatedItemSize = null } = $$props;
  let { stickyIndices = null } = $$props;
  let { getKey = null } = $$props;
  let { scrollDirection = DIRECTION.VERTICAL } = $$props;
  let { scrollOffset = null } = $$props;
  let { scrollToIndex = null } = $$props;
  let { scrollToAlignment = null } = $$props;
  let { scrollToBehaviour = "instant" } = $$props;
  let { overscanCount = 3 } = $$props;
  const dispatchEvent = createEventDispatcher();
  const sizeAndPositionManager = new SizeAndPositionManager({
    itemCount,
    itemSize,
    estimatedItemSize: getEstimatedItemSize()
  });
  let mounted = false;
  let wrapper;
  let items = [];
  let state = {
    offset: scrollOffset || scrollToIndex != null && items.length && getOffsetForIndex(scrollToIndex) || 0,
    scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
  };
  let prevState = state;
  let prevProps = {
    scrollToIndex,
    scrollToAlignment,
    scrollOffset,
    itemCount,
    itemSize,
    estimatedItemSize
  };
  let styleCache = {};
  let wrapperStyle = "";
  let innerStyle = "";
  refresh();
  onMount(() => {
    $$invalidate(18, mounted = true);
    wrapper.addEventListener("scroll", handleScroll, thirdEventArg);
    if (scrollOffset != null) {
      scrollTo(scrollOffset);
    } else if (scrollToIndex != null) {
      scrollTo(getOffsetForIndex(scrollToIndex));
    }
  });
  onDestroy(() => {
    if (mounted)
      wrapper.removeEventListener("scroll", handleScroll);
  });
  function propsUpdated() {
    if (!mounted)
      return;
    const scrollPropsHaveChanged = prevProps.scrollToIndex !== scrollToIndex || prevProps.scrollToAlignment !== scrollToAlignment;
    const itemPropsHaveChanged = prevProps.itemCount !== itemCount || prevProps.itemSize !== itemSize || prevProps.estimatedItemSize !== estimatedItemSize;
    if (itemPropsHaveChanged) {
      sizeAndPositionManager.updateConfig({
        itemSize,
        itemCount,
        estimatedItemSize: getEstimatedItemSize()
      });
      recomputeSizes();
    }
    if (prevProps.scrollOffset !== scrollOffset) {
      $$invalidate(19, state = {
        offset: scrollOffset || 0,
        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
      });
    } else if (typeof scrollToIndex === "number" && (scrollPropsHaveChanged || itemPropsHaveChanged)) {
      $$invalidate(19, state = {
        offset: getOffsetForIndex(scrollToIndex, scrollToAlignment, itemCount),
        scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
      });
    }
    prevProps = {
      scrollToIndex,
      scrollToAlignment,
      scrollOffset,
      itemCount,
      itemSize,
      estimatedItemSize
    };
  }
  function stateUpdated() {
    if (!mounted)
      return;
    const { offset, scrollChangeReason } = state;
    if (prevState.offset !== offset || prevState.scrollChangeReason !== scrollChangeReason) {
      refresh();
    }
    if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {
      scrollTo(offset);
    }
    prevState = state;
  }
  function refresh() {
    const { offset } = state;
    const { start, stop } = sizeAndPositionManager.getVisibleRange({
      containerSize: scrollDirection === DIRECTION.VERTICAL ? height : width,
      offset,
      overscanCount
    });
    let updatedItems = [];
    const totalSize = sizeAndPositionManager.getTotalSize();
    if (scrollDirection === DIRECTION.VERTICAL) {
      $$invalidate(3, wrapperStyle = `height:${height}px;width:${width};`);
      $$invalidate(4, innerStyle = `flex-direction:column;height:${totalSize}px;`);
    } else {
      $$invalidate(3, wrapperStyle = `height:${height};width:${width}px`);
      $$invalidate(4, innerStyle = `min-height:100%;width:${totalSize}px;`);
    }
    const hasStickyIndices = stickyIndices != null && stickyIndices.length !== 0;
    if (hasStickyIndices) {
      for (let i = 0; i < stickyIndices.length; i++) {
        const index = stickyIndices[i];
        updatedItems.push({ index, style: getStyle(index, true) });
      }
    }
    if (start !== void 0 && stop !== void 0) {
      for (let index = start; index <= stop; index++) {
        if (hasStickyIndices && stickyIndices.includes(index)) {
          continue;
        }
        updatedItems.push({ index, style: getStyle(index, false) });
      }
      dispatchEvent("itemsUpdated", { start, end: stop });
    }
    $$invalidate(2, items = updatedItems);
  }
  function scrollTo(value) {
    if ("scroll" in wrapper) {
      wrapper.scroll({
        [SCROLL_PROP[scrollDirection]]: value,
        behavior: scrollToBehaviour
      });
    } else {
      $$invalidate(1, wrapper[SCROLL_PROP_LEGACY[scrollDirection]] = value, wrapper);
    }
  }
  function recomputeSizes(startIndex = 0) {
    styleCache = {};
    sizeAndPositionManager.resetItem(startIndex);
    refresh();
  }
  function getOffsetForIndex(index, align = scrollToAlignment, _itemCount = itemCount) {
    if (index < 0 || index >= _itemCount) {
      index = 0;
    }
    return sizeAndPositionManager.getUpdatedOffsetForIndex({
      align,
      containerSize: scrollDirection === DIRECTION.VERTICAL ? height : width,
      currentOffset: state.offset || 0,
      targetIndex: index
    });
  }
  function handleScroll(event) {
    const offset = getWrapperOffset();
    if (offset < 0 || state.offset === offset || event.target !== wrapper)
      return;
    $$invalidate(19, state = {
      offset,
      scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED
    });
    dispatchEvent("afterScroll", { offset, event });
  }
  function getWrapperOffset() {
    return wrapper[SCROLL_PROP_LEGACY[scrollDirection]];
  }
  function getEstimatedItemSize() {
    return estimatedItemSize || typeof itemSize === "number" && itemSize || 50;
  }
  function getStyle(index, sticky) {
    if (styleCache[index])
      return styleCache[index];
    const { size, offset } = sizeAndPositionManager.getSizeAndPositionForIndex(index);
    let style;
    if (scrollDirection === DIRECTION.VERTICAL) {
      style = `left:0;width:100%;height:${size}px;`;
      if (sticky) {
        style += `position:sticky;flex-grow:0;z-index:1;top:0;margin-top:${offset}px;margin-bottom:${-(offset + size)}px;`;
      } else {
        style += `position:absolute;top:${offset}px;`;
      }
    } else {
      style = `top:0;width:${size}px;`;
      if (sticky) {
        style += `position:sticky;z-index:1;left:0;margin-left:${offset}px;margin-right:${-(offset + size)}px;`;
      } else {
        style += `position:absolute;height:100%;left:${offset}px;`;
      }
    }
    return styleCache[index] = style;
  }
  $$self.$$.on_mount.push(function() {
    if (height === void 0 && !("height" in $$props || $$self.$$.bound[$$self.$$.props["height"]])) {
      console.warn("<VirtualList> was created without expected prop 'height'");
    }
    if (itemCount === void 0 && !("itemCount" in $$props || $$self.$$.bound[$$self.$$.props["itemCount"]])) {
      console.warn("<VirtualList> was created without expected prop 'itemCount'");
    }
    if (itemSize === void 0 && !("itemSize" in $$props || $$self.$$.bound[$$self.$$.props["itemSize"]])) {
      console.warn("<VirtualList> was created without expected prop 'itemSize'");
    }
  });
  const writable_props = [
    "height",
    "width",
    "itemCount",
    "itemSize",
    "estimatedItemSize",
    "stickyIndices",
    "getKey",
    "scrollDirection",
    "scrollOffset",
    "scrollToIndex",
    "scrollToAlignment",
    "scrollToBehaviour",
    "overscanCount"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<VirtualList> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapper = $$value;
      $$invalidate(1, wrapper);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(5, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(6, width = $$props2.width);
    if ("itemCount" in $$props2)
      $$invalidate(7, itemCount = $$props2.itemCount);
    if ("itemSize" in $$props2)
      $$invalidate(8, itemSize = $$props2.itemSize);
    if ("estimatedItemSize" in $$props2)
      $$invalidate(9, estimatedItemSize = $$props2.estimatedItemSize);
    if ("stickyIndices" in $$props2)
      $$invalidate(10, stickyIndices = $$props2.stickyIndices);
    if ("getKey" in $$props2)
      $$invalidate(0, getKey = $$props2.getKey);
    if ("scrollDirection" in $$props2)
      $$invalidate(11, scrollDirection = $$props2.scrollDirection);
    if ("scrollOffset" in $$props2)
      $$invalidate(12, scrollOffset = $$props2.scrollOffset);
    if ("scrollToIndex" in $$props2)
      $$invalidate(13, scrollToIndex = $$props2.scrollToIndex);
    if ("scrollToAlignment" in $$props2)
      $$invalidate(14, scrollToAlignment = $$props2.scrollToAlignment);
    if ("scrollToBehaviour" in $$props2)
      $$invalidate(15, scrollToBehaviour = $$props2.scrollToBehaviour);
    if ("overscanCount" in $$props2)
      $$invalidate(16, overscanCount = $$props2.overscanCount);
    if ("$$scope" in $$props2)
      $$invalidate(20, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    thirdEventArg,
    onMount,
    onDestroy,
    createEventDispatcher,
    SizeAndPositionManager,
    DIRECTION,
    SCROLL_CHANGE_REASON,
    SCROLL_PROP,
    SCROLL_PROP_LEGACY,
    height,
    width,
    itemCount,
    itemSize,
    estimatedItemSize,
    stickyIndices,
    getKey,
    scrollDirection,
    scrollOffset,
    scrollToIndex,
    scrollToAlignment,
    scrollToBehaviour,
    overscanCount,
    dispatchEvent,
    sizeAndPositionManager,
    mounted,
    wrapper,
    items,
    state,
    prevState,
    prevProps,
    styleCache,
    wrapperStyle,
    innerStyle,
    propsUpdated,
    stateUpdated,
    refresh,
    scrollTo,
    recomputeSizes,
    getOffsetForIndex,
    handleScroll,
    getWrapperOffset,
    getEstimatedItemSize,
    getStyle
  });
  $$self.$inject_state = ($$props2) => {
    if ("height" in $$props2)
      $$invalidate(5, height = $$props2.height);
    if ("width" in $$props2)
      $$invalidate(6, width = $$props2.width);
    if ("itemCount" in $$props2)
      $$invalidate(7, itemCount = $$props2.itemCount);
    if ("itemSize" in $$props2)
      $$invalidate(8, itemSize = $$props2.itemSize);
    if ("estimatedItemSize" in $$props2)
      $$invalidate(9, estimatedItemSize = $$props2.estimatedItemSize);
    if ("stickyIndices" in $$props2)
      $$invalidate(10, stickyIndices = $$props2.stickyIndices);
    if ("getKey" in $$props2)
      $$invalidate(0, getKey = $$props2.getKey);
    if ("scrollDirection" in $$props2)
      $$invalidate(11, scrollDirection = $$props2.scrollDirection);
    if ("scrollOffset" in $$props2)
      $$invalidate(12, scrollOffset = $$props2.scrollOffset);
    if ("scrollToIndex" in $$props2)
      $$invalidate(13, scrollToIndex = $$props2.scrollToIndex);
    if ("scrollToAlignment" in $$props2)
      $$invalidate(14, scrollToAlignment = $$props2.scrollToAlignment);
    if ("scrollToBehaviour" in $$props2)
      $$invalidate(15, scrollToBehaviour = $$props2.scrollToBehaviour);
    if ("overscanCount" in $$props2)
      $$invalidate(16, overscanCount = $$props2.overscanCount);
    if ("mounted" in $$props2)
      $$invalidate(18, mounted = $$props2.mounted);
    if ("wrapper" in $$props2)
      $$invalidate(1, wrapper = $$props2.wrapper);
    if ("items" in $$props2)
      $$invalidate(2, items = $$props2.items);
    if ("state" in $$props2)
      $$invalidate(19, state = $$props2.state);
    if ("prevState" in $$props2)
      prevState = $$props2.prevState;
    if ("prevProps" in $$props2)
      prevProps = $$props2.prevProps;
    if ("styleCache" in $$props2)
      styleCache = $$props2.styleCache;
    if ("wrapperStyle" in $$props2)
      $$invalidate(3, wrapperStyle = $$props2.wrapperStyle);
    if ("innerStyle" in $$props2)
      $$invalidate(4, innerStyle = $$props2.innerStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*scrollToIndex, scrollToAlignment, scrollOffset, itemCount, itemSize, estimatedItemSize*/
    29568) {
      $: {
        scrollToIndex, scrollToAlignment, scrollOffset, itemCount, itemSize, estimatedItemSize;
        propsUpdated();
      }
    }
    if ($$self.$$.dirty[0] & /*state*/
    524288) {
      $: {
        state;
        stateUpdated();
      }
    }
    if ($$self.$$.dirty[0] & /*height, width, stickyIndices, mounted*/
    263264) {
      $: {
        height, width, stickyIndices;
        if (mounted)
          recomputeSizes(0);
      }
    }
  };
  return [
    getKey,
    wrapper,
    items,
    wrapperStyle,
    innerStyle,
    height,
    width,
    itemCount,
    itemSize,
    estimatedItemSize,
    stickyIndices,
    scrollDirection,
    scrollOffset,
    scrollToIndex,
    scrollToAlignment,
    scrollToBehaviour,
    overscanCount,
    recomputeSizes,
    mounted,
    state,
    $$scope,
    slots,
    div1_binding
  ];
}
var VirtualList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        height: 5,
        width: 6,
        itemCount: 7,
        itemSize: 8,
        estimatedItemSize: 9,
        stickyIndices: 10,
        getKey: 0,
        scrollDirection: 11,
        scrollOffset: 12,
        scrollToIndex: 13,
        scrollToAlignment: 14,
        scrollToBehaviour: 15,
        overscanCount: 16,
        recomputeSizes: 17
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VirtualList",
      options,
      id: create_fragment.name
    });
  }
  get height() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemCount() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemCount(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get itemSize() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set itemSize(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get estimatedItemSize() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set estimatedItemSize(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stickyIndices() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stickyIndices(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getKey() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set getKey(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollDirection() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollDirection(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollOffset() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollOffset(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToIndex() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToIndex(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToAlignment() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToAlignment(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollToBehaviour() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollToBehaviour(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get overscanCount() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set overscanCount(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get recomputeSizes() {
    return this.$$.ctx[17];
  }
  set recomputeSizes(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var VirtualList_default = VirtualList;

// node_modules/.pnpm/svelecte@4.0.1_svelte@4.2.15/node_modules/svelecte/dist/utils/dropdown.js
function pixelGetter(element2, prop) {
  const styles = window.getComputedStyle(element2);
  let { groups: { value, unit } } = styles[prop].match(/(?<value>\d+)(?<unit>[a-zA-Z]+)/);
  let floatValue = parseFloat(
    /** @type {unknown} */
    value
  );
  if (unit !== "px") {
    const el = unit === "rem" ? document.documentElement : element2.parentElement.parentElement;
    const multipler = parseFloat(window.getComputedStyle(el).fontSize.match(/\d+/).shift());
    floatValue = multipler * floatValue;
  }
  return floatValue;
}
function isOutOfViewport(elem) {
  const parentBounding = elem.parentElement.parentElement.getBoundingClientRect();
  const bounding = elem.getBoundingClientRect();
  const out = {};
  out.top = parentBounding.top < 0;
  out.left = parentBounding.left < 0;
  out.bottom = parentBounding.bottom + bounding.height > (window.innerHeight || document.documentElement.clientHeight) && parentBounding.top > bounding.height && (window.innerHeight || document.documentElement.clientHeight) > bounding.height + 50;
  out.right = parentBounding.right > (window.innerWidth || document.documentElement.clientWidth);
  out.any = out.top || out.left || out.bottom || out.right;
  return out;
}
function positionDropdown(isOpened, scrollContainer, renderDropdown) {
  if (!scrollContainer || !renderDropdown)
    return;
  const outVp = isOutOfViewport(scrollContainer);
  if (outVp.bottom && !outVp.top) {
    scrollContainer.parentElement.style.bottom = scrollContainer.parentElement.parentElement.clientHeight + 1 + "px";
  } else if (!isOpened || outVp.top) {
    scrollContainer.parentElement.style.bottom = "";
  }
}
function virtualListDimensionsResolver(refVirtualList, scrollContainer, options) {
  let vl_itemSize;
  const vl_height = pixelGetter(scrollContainer, "maxHeight") - pixelGetter(scrollContainer, "paddingTop") - pixelGetter(scrollContainer, "paddingBottom");
  scrollContainer.parentElement.style.cssText = "opacity: 0; display: block";
  const firstItem = refVirtualList.$$.ctx[1].firstElementChild.firstElementChild;
  if (firstItem) {
    firstItem.style = "";
    const firstSize = firstItem.getBoundingClientRect().height;
    const secondItem = refVirtualList.$$.ctx[1].firstElementChild.firstElementChild.nextElementSibling;
    let secondSize;
    if (secondItem) {
      secondItem.style = "";
      secondSize = secondItem.getBoundingClientRect().height;
    }
    if (secondSize && firstSize !== secondSize) {
      const groupHeaderSize = options[0].$isGroupHeader ? firstSize : secondSize;
      const regularItemSize = options[0].$isGroupHeader ? secondSize : firstSize;
      vl_itemSize = options.map((opt) => opt.$isGroupHeader ? groupHeaderSize : regularItemSize);
    } else {
      vl_itemSize = firstSize;
    }
  }
  scrollContainer.parentElement.style.cssText = "";
  return {
    size: vl_itemSize,
    height: vl_height
  };
}
function scrollIntoView({ container, scrollContainer, virtualList, center }, dropdownIndex) {
  if (virtualList || !container)
    return;
  const focusedEl = container.querySelector(`[data-pos="${dropdownIndex}"]`);
  if (!focusedEl)
    return;
  const focusedRect = focusedEl.getBoundingClientRect();
  const menuRect = scrollContainer.getBoundingClientRect();
  const overScroll = focusedEl.offsetHeight / 3;
  const centerOffset = center ? scrollContainer.offsetHeight / 2 : 0;
  switch (true) {
    case focusedEl.offsetTop < scrollContainer.scrollTop:
      scrollContainer.scrollTop = focusedEl.offsetTop - overScroll + centerOffset;
      break;
    case focusedEl.offsetTop + focusedRect.height > scrollContainer.scrollTop + menuRect.height:
      scrollContainer.scrollTop = focusedEl.offsetTop + focusedRect.height - scrollContainer.offsetHeight + overScroll + centerOffset;
      break;
  }
}

// node_modules/.pnpm/svelecte@4.0.1_svelte@4.2.15/node_modules/svelecte/dist/utils/list.js
function createConfig(valueField, labelField, optLabel, optItems) {
  return {
    optionProps: [],
    optionsWithGroups: false,
    valueField,
    labelField,
    optLabel,
    optItems
  };
}
function initSelection(options, initialValue, valueAsObject, groupItemsField, valueField) {
  if (valueAsObject)
    return Array.isArray(initialValue) ? initialValue : [initialValue];
  const initialValue_array = Array.isArray(initialValue) ? initialValue : [initialValue];
  const initialSelection = options.reduce((res, val, i) => {
    const opt_group = val[groupItemsField] && Array.isArray(val) ? val[groupItemsField] : null;
    if (opt_group) {
      const selected = opt_group.reduce((res2, group_item) => {
        if (initialValue_array.includes(group_item[valueField]))
          res2.push(group_item);
        return res2;
      }, []);
      if (selected.length) {
        res.push(...selected);
        return res;
      }
    }
    return res;
  }, []);
  return initialSelection.sort((a, b) => initialValue_array.indexOf(a[valueField]) < initialValue_array.indexOf(b[valueField]) ? -1 : 1);
}
function ensureObjectArray(options, valueField, labelField) {
  return typeof options[0] === "object" ? options : options.map((arrayValue) => ({
    [valueField || "value"]: arrayValue,
    [labelField || "text"]: arrayValue
  }));
}
function flatList(options, config2) {
  const flatOpts = options.reduce((res, opt, i) => {
    if (opt[config2.optItems]) {
      if (opt[config2.optItems].length === 0)
        return res;
      config2.optionsWithGroups = true;
      res.push({ label: opt[config2.optLabel], $isGroupHeader: true });
      res.push(...opt[config2.optItems].map((_opt) => {
        _opt.$isGroupItem = true;
        return _opt;
      }));
      return res;
    }
    res.push(opt);
    return res;
  }, []);
  updateOptionProps(flatOpts, config2);
  return flatOpts;
}
function updateOptionProps(options, config2) {
  options.some((opt) => {
    if (opt.$isGroupHeader)
      return false;
    config2.optionProps = getFilterProps(opt);
    return true;
  });
}
function getFilterProps(object) {
  const exclude = ["$disabled", "$isGroupHeader", "$isGroupItem", "$created", "$selected"];
  return Object.keys(object).filter((prop) => !exclude.includes(prop));
}
function filterList(options, inputValue, excludeSelected, config2, searchProps) {
  if (excludeSelected) {
    options = options.filter((opt) => !excludeSelected.has(opt[config2.valueField])).filter((opt, idx, self) => {
      if (opt.$isGroupHeader && (self[idx + 1] && self[idx + 1].$isGroupHeader || self.length <= 1 || self.length - 1 === idx))
        return false;
      return true;
    });
  }
  if (searchProps.disabled || !inputValue)
    return options;
  const sifter = new sifter_default(options);
  if (config2.optionsWithGroups || searchProps.skipSort) {
    sifter.getSortFunction = () => null;
  }
  let conjunction = "and";
  if (inputValue.includes("|")) {
    conjunction = "or";
    inputValue = inputValue.split("|").map((word) => word.trim()).join(" ");
  }
  const result = sifter.search(inputValue, {
    fields: searchProps.fields || config2.optionProps,
    sort: searchProps.sort || createSifterSortField(config2.labelField),
    conjunction: searchProps.conjunction || conjunction,
    nesting: searchProps.nesting || false
  });
  const mapped = config2.optionsWithGroups ? result.items.reduce((res, item) => {
    const opt = options[item.id];
    if (excludeSelected && opt.isSelected)
      return res;
    const lastPos = res.push(opt);
    if (opt.$isGroupItem) {
      const prevItems = options.slice(0, item.id);
      let prev = null;
      do {
        prev = prevItems.pop();
        prev && prev.$isGroupHeader && !res.includes(prev) && res.splice(lastPos - 1, 0, prev);
      } while (prev && !prev.$isGroupHeader);
    }
    return res;
  }, []) : result.items.map((item) => options[item.id]);
  return mapped;
}
function createSifterSortField(prop) {
  return [{ field: prop, direction: "asc" }];
}
function fieldInit(type, options, groupItemsField) {
  const isValue = type === "value";
  let val = isValue ? "value" : "text";
  if (options && options.length) {
    const firstItem = options[0][groupItemsField] ? options[0][groupItemsField][0] : options[0];
    if (!firstItem || typeof firstItem === "string")
      return val;
    const autoAddItem = isValue ? 0 : 1;
    const guessList = isValue ? ["id", "value", "ID"] : ["name", "title", "label"];
    val = Object.keys(firstItem).filter((prop) => guessList.includes(prop)).concat([Object.keys(firstItem)[autoAddItem]]).shift();
  }
  return val;
}

// node_modules/.pnpm/svelecte@4.0.1_svelte@4.2.15/node_modules/svelecte/dist/utils/actions.js
function bindItem(node, selectedObject) {
  node.bound_item = selectedObject;
  return {
    destroy: () => {
    }
  };
}

// node_modules/.pnpm/svelecte@4.0.1_svelte@4.2.15/node_modules/svelecte/dist/Svelecte.svelte
var { Object: Object_12, console: console_1 } = globals;
var file2 = "node_modules/.pnpm/svelecte@4.0.1_svelte@4.2.15/node_modules/svelecte/dist/Svelecte.svelte";
function add_css2(target) {
  append_styles(target, "svelte-hi60qz", `.sv-hidden-element{opacity:0;position:absolute;z-index:-2;top:0;height:var(--sv-min-height, 30px)}.a11y-text.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{z-index:9999;border:0px;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0px;white-space:nowrap}.svelecte.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{position:relative;flex:1 1 auto;color:var(--sv-color, inherit);&.is-disabled > .sv-control {
      background-color: var(--sv-disabled-bg, #eee);
    }}.sv-control.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{display:flex;align-items:center;border:var(--sv-border, 1px solid #ccc);border-radius:var(--sv-border-radius, 4px);background-color:var(--sv-control-bg, var(--sv-bg, #fff));min-height:var(--sv-min-height, 30px)}.sv-control--selection.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{display:flex;flex-wrap:wrap;align-items:center;flex:1;min-width:0;gap:4px;padding:var(--sv-general-padding, 4px);min-height:24px;&.is-single {
      flex-wrap: nowrap;
    }}.sv-item--container{display:flex;min-width:0}.sv-item--wrap{display:flex;min-width:0;padding:var(--sv-item-wrap-padding, 3px 3px 3px 6px);&.is-multi {
      background-color: var(--sv-item-selected-bg, #efefef);
    }}.sv-item--content{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.sv-item--btn{position:relative;display:inline-flex;align-items:center;align-self:stretch;padding:0 4px;box-sizing:border-box;border-radius:calc(var(--sv-border-radius, 4px) / 2);border-width:0;margin:0;cursor:pointer;background-color:var(--sv-item-btn-bg, var(--sv-item-selected-bg, #efefef));& > svg {
      fill: var(--sv-item-btn-color, var(--sv-icon-color, #bbb));
    };&:hover {
      background-color: var(--sv-item-btn-bg-hover, #ddd);
      & > svg {
        fill: var(--sv-item-btn-color-hover, #777);
      }
    }}.sv-buttons.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{display:flex;align-self:stretch;position:relative}.sv-btn-indicator.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{color:var(--sv-icon-color, #bbb);display:flex;transition:color 150ms ease 0s;box-sizing:border-box;background-color:var(--sv-icon-bg, transparent);border:var(--sv-btn-border, 0);padding:0;margin:var(--sv-general-padding, 4px);align-items:center;fill:currentcolor;line-height:1;stroke:currentcolor;stroke-width:0px;&:hover {
      color: var(--sv-icon-color-hover, #777);
    }}.sv-btn-separator.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{align-self:stretch;background-color:var(--sv-separator-bg, #ccc);margin-bottom:var(--sv-general-padding, 4px);margin-top:var(--sv-general-padding, 4px);width:1px;box-sizing:border-box}.indicator-icon.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{width:var(--sv-icon-size, 20px);height:var(--sv-icon-size, 20px)}.is-loading.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz:after{animation:svelte-hi60qz-spinAround 0.5s infinite linear;border:var(--sv-loader-border, 2px solid #ccc);border-radius:50%;border-right-color:transparent;border-top-color:transparent;content:"";display:block;height:var(--sv-icon-size, 20px);width:var(--sv-icon-size, 20px);right:var(--sv-general-padding, 4px);top:calc(50% - (var(--sv-icon-size, 20px) / 2));position:absolute !important;box-sizing:border-box}@keyframes svelte-hi60qz-spinAround{from{transform:rotate(0deg)
    }to{transform:rotate(359deg)
    }}.sv_dropdown.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{margin:var(--sv-dropdown-offset, 1px) 0;box-sizing:border-box;position:absolute;min-width:100%;width:var(--sv-dropdown-width, auto);background-color:var(--sv-dropdown-bg, var(--sv-bg, #fff));overflow-y:auto;overflow-x:hidden;border:var(--sv-dropdown-border, 1px solid rgba(0,0,0,0.15));border-radius:var(--sv-border-radius, 4px);box-shadow:var(--sv-dropdown-shadow, 0 6px 12px #0000002d);opacity:0;z-index:-1000;pointer-events:none;&.is-open {
      opacity: 1;
      z-index: 2;
      pointer-events: auto;
    }}.sv-dropdown-scroll.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{padding:0;box-sizing:border-box;max-height:var(--sv-dropdown-height, 320px);overflow-y:auto;overflow-x:hidden;&.has-items {
      padding: 4px;
    }}.in-dropdown.is-selected.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{background-color:var(--sv-dropdown-selected-bg, #ECF3F9)}.in-dropdown.is-disabled.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{opacity:0.5;cursor:not-allowed}.in-dropdown.sv-dd-item-active.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz,.in-dropdown.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz:hover,.in-dropdown.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz:active{background-color:var(--sv-dropdown-active-bg, #F2F5F8)}.is-dropdown-row.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{padding:var(--sv-general-padding, 4px)}.sv-dropdown-scroll.has-items.svelte-hi60qz+.is-dropdown-row.svelte-hi60qz.svelte-hi60qz{border-top:1px solid transparent;border-color:var(--sv-separator-bg, #ccc)}.creatable-row.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{width:100%;border:0;background-color:inherit;box-sizing:border-box;display:flex;justify-content:space-between;align-items:center;border-radius:calc(var(--sv-border-radius, 4px) / 2);padding:var(--sv-item-wrap-padding, 3px 3px 3px 6px);&:hover,
    &:active,
    &.active {
      background-color: var(--sv-dropdown-active-bg, #F2F5F8);
    };&.active.is-disabled {
      opacity: 0.5;
      background-color: var(--sv-create-disabled-bg, #fcbaba);
    };&.is-disabled {
      opacity: 0.5;
      cursor: not-allowed;
    };& > .is-loading {
      position: relative;
      &:after {
        left: calc(100% + 4px);
      }
    }}.shortcut.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{display:flex;align-items:center;align-content:center}.shortcut.svelte-hi60qz>kbd.svelte-hi60qz.svelte-hi60qz{border:var(--sv-create-kbd-border, 1px solid #efefef);border-radius:var(--sv-border-radius, 4px);padding:0px 6px;margin:-1px 0;background-color:var(--sv-create-kbd-bg, #fff)}.sv-input--sizer.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{position:relative;display:inline-grid;vertical-align:top;align-items:center;&:not(:focus-within) {
      position: absolute;
      pointer-events: none;
    };&:after {
      content: attr(data-value) ' ';
      visibility: hidden;
      white-space: pre-wrap;
    }}.has-items.svelte-hi60qz .keep-value.svelte-hi60qz.svelte-hi60qz:not(:focus){color:transparent}.is-focused.svelte-hi60qz .is-single.has-items.has-input.svelte-hi60qz>.sv-item--container.svelte-hi60qz{opacity:0.2}.sv-input--sizer.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz:after,.sv-input--text.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{width:auto;min-width:1em;grid-area:1 / 2;font:inherit;padding:0 0.25em;margin:0;resize:none;background:none;appearance:none;border:none}.has-items.svelte-hi60qz .sv-input--text.svelte-hi60qz.svelte-hi60qz{padding-left:0;margin-left:-2px}.sv-input--text.svelte-hi60qz.svelte-hi60qz.svelte-hi60qz{outline:none;&:placeholder {
      color: var(--sv-placeholder-color, #ccccd6);
    }}
/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3ZlbGVjdGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQWkxQ1Usa0JBQW9CLENBQUUsT0FBTyxDQUFFLENBQUMsQ0FBRSxRQUFRLENBQUUsUUFBUSxDQUFFLE9BQU8sQ0FBRSxFQUFFLENBQUUsR0FBRyxDQUFFLENBQUMsQ0FBRSxNQUFNLENBQUUsSUFBSSxlQUFlLENBQUMsS0FBSyxDQUFDLENBdUNySCxvREFBVyxDQUNULE9BQU8sQ0FBRSxJQUFJLENBQ2IsTUFBTSxDQUFFLEdBQUcsQ0FDWCxJQUFJLENBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDOUIsTUFBTSxDQUFFLEdBQUcsQ0FDWCxLQUFLLENBQUUsR0FBRyxDQUNWLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFFBQVEsQ0FBRSxNQUFNLENBQ2hCLE9BQU8sQ0FBRSxHQUFHLENBQ1osV0FBVyxDQUFFLE1BQ2YsQ0FDQSxtREFBVSxDQUNSLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLElBQUksQ0FBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDZCxLQUFLLENBQUUsSUFBSSxVQUFVLENBQUMsUUFBUSxDQUFDLENBRS9CLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7QUFDaEMsTUFBTSxrQkFBa0IsSUFBSSxnQkFBZ0IsQ0FBQyxLQUFLLENBQUM7QUFDbkQsS0FDRSxDQUVBLHFEQUFZLENBQ1YsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixNQUFNLENBQUUsSUFBSSxXQUFXLENBQUMsZUFBZSxDQUFDLENBQ3hDLGFBQWEsQ0FBRSxJQUFJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUMzQyxnQkFBZ0IsQ0FBRSxJQUFJLGVBQWUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUMxRCxVQUFVLENBQUUsSUFBSSxlQUFlLENBQUMsS0FBSyxDQUN2QyxDQUVBLGdFQUF1QixDQUNyQixPQUFPLENBQUUsSUFBSSxDQUNiLFNBQVMsQ0FBRSxJQUFJLENBQ2YsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsSUFBSSxDQUFFLENBQUMsQ0FDUCxTQUFTLENBQUUsQ0FBQyxDQUNaLEdBQUcsQ0FBRSxHQUFHLENBQ1IsT0FBTyxDQUFFLElBQUksb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQ3ZDLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLENBQUMsVUFBVSxDQUFDO0FBQ2hCLE1BQU0sV0FBVyxNQUFNO0FBQ3ZCLEtBQ0UsQ0FDUSxtQkFBcUIsQ0FDM0IsT0FBTyxDQUFFLElBQUksQ0FDYixTQUFTLENBQUUsQ0FDYixDQUNRLGNBQWdCLENBQ3RCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsU0FBUyxDQUFFLENBQUMsQ0FDWixPQUFPLENBQUUsSUFBSSxzQkFBc0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUNyRCxDQUFDLFNBQVMsQ0FBQztBQUNmLE1BQU0sa0JBQWtCLElBQUkscUJBQXFCLENBQUMsUUFBUSxDQUFDO0FBQzNELEtBRUUsQ0FDUSxpQkFBbUIsQ0FDekIsUUFBUSxDQUFFLE1BQU0sQ0FDaEIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsYUFBYSxDQUFFLFFBQ2pCLENBRVEsYUFBZSxDQUNyQixRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsV0FBVyxDQUNwQixXQUFXLENBQUUsTUFBTSxDQUNuQixVQUFVLENBQUUsT0FBTyxDQUNuQixPQUFPLENBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FDZCxVQUFVLENBQUUsVUFBVSxDQUN0QixhQUFhLENBQUUsS0FBSyxJQUFJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDckQsWUFBWSxDQUFFLENBQUMsQ0FDZixNQUFNLENBQUUsQ0FBQyxDQUNULE1BQU0sQ0FBRSxPQUFPLENBQ2YsZ0JBQWdCLENBQUUsSUFBSSxnQkFBZ0IsQ0FBQyxvQ0FBb0MsQ0FBQyxDQUU1RSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUNaLE1BQU0sTUFBTSxJQUFJLG1CQUFtQixDQUFDLDJCQUEyQixDQUFDO0FBQ2hFLEtBQUksQ0FDQSxDQUFDLE1BQU0sQ0FBQztBQUNaLE1BQU0sa0JBQWtCLElBQUksc0JBQXNCLENBQUMsS0FBSyxDQUFDO0FBQ3pELE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDZCxRQUFRLE1BQU0sSUFBSSx5QkFBeUIsQ0FBQyxLQUFLLENBQUM7QUFDbEQsT0FBTTtBQUNOLEtBQ0UsQ0FLQSxxREFBWSxDQUNWLE9BQU8sQ0FBRSxJQUFJLENBQ2IsVUFBVSxDQUFFLE9BQU8sQ0FDbkIsUUFBUSxDQUFFLFFBQ1osQ0FDQSwyREFBa0IsQ0FDaEIsS0FBSyxDQUFFLElBQUksZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUNqQyxPQUFPLENBQUUsSUFBSSxDQUNiLFVBQVUsQ0FBRSxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQy9CLFVBQVUsQ0FBRSxVQUFVLENBQ3RCLGdCQUFnQixDQUFFLElBQUksWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUNoRCxNQUFNLENBQUUsSUFBSSxlQUFlLENBQUMsRUFBRSxDQUFDLENBQy9CLE9BQU8sQ0FBRSxDQUFDLENBQ1YsTUFBTSxDQUFFLElBQUksb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQ3RDLFdBQVcsQ0FBRSxNQUFNLENBQ25CLElBQUksQ0FBRSxZQUFZLENBQ2xCLFdBQVcsQ0FBRSxDQUFDLENBQ2QsTUFBTSxDQUFFLFlBQVksQ0FDcEIsWUFBWSxDQUFFLEdBQUcsQ0FDakIsQ0FBQyxNQUFNLENBQUM7QUFDWixNQUFNLE9BQU8sSUFBSSxxQkFBcUIsQ0FBQyxLQUFLLENBQUM7QUFDN0MsS0FDRSxDQUNBLDJEQUFrQixDQUNoQixVQUFVLENBQUUsT0FBTyxDQUNuQixnQkFBZ0IsQ0FBRSxJQUFJLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUM5QyxhQUFhLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsQ0FDN0MsVUFBVSxDQUFFLElBQUksb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQzFDLEtBQUssQ0FBRSxHQUFHLENBQ1YsVUFBVSxDQUFFLFVBQ2QsQ0FDQSx5REFBZ0IsQ0FDZCxLQUFLLENBQUUsSUFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLENBQ2hDLE1BQU0sQ0FBRSxJQUFJLGNBQWMsQ0FBQyxLQUFLLENBQ2xDLENBQ0EscURBQVcsTUFBTyxDQUNoQixTQUFTLENBQUUsd0JBQVUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FDMUMsTUFBTSxDQUFFLElBQUksa0JBQWtCLENBQUMsZUFBZSxDQUFDLENBQy9DLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLGtCQUFrQixDQUFFLFdBQVcsQ0FDL0IsZ0JBQWdCLENBQUUsV0FBVyxDQUM3QixPQUFPLENBQUUsRUFBRSxDQUNYLE9BQU8sQ0FBRSxLQUFLLENBQ2QsTUFBTSxDQUFFLElBQUksY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUNqQyxLQUFLLENBQUUsSUFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLENBQ2hDLEtBQUssQ0FBRSxJQUFJLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUNyQyxHQUFHLENBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ2hELFFBQVEsQ0FBRSxRQUFRLENBQUMsVUFBVSxDQUM3QixVQUFVLENBQUUsVUFDZCxDQUNBLFdBQVcsd0JBQVcsQ0FDcEIsSUFBSyxDQUNILFNBQVMsQ0FBRSxPQUFPLElBQUk7QUFDNUIsSUFBSSxDQUNBLEVBQUcsQ0FDRCxTQUFTLENBQUUsT0FBTyxNQUFNO0FBQzlCLElBQUksQ0FDRixDQU1BLHNEQUFhLENBQ1gsTUFBTSxDQUFFLElBQUksb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUN4QyxVQUFVLENBQUUsVUFBVSxDQUN0QixRQUFRLENBQUUsUUFBUSxDQUNsQixTQUFTLENBQUUsSUFBSSxDQUNmLEtBQUssQ0FBRSxJQUFJLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUNyQyxnQkFBZ0IsQ0FBRSxJQUFJLGdCQUFnQixDQUFDLG1CQUFtQixDQUFDLENBQzNELFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLE1BQU0sQ0FBRSxJQUFJLG9CQUFvQixDQUFDLDJCQUEyQixDQUFDLENBQzdELGFBQWEsQ0FBRSxJQUFJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUMzQyxVQUFVLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxxQkFBcUIsQ0FBQyxDQUMzRCxPQUFPLENBQUUsQ0FBQyxDQUNWLE9BQU8sQ0FBRSxLQUFLLENBQ2QsY0FBYyxDQUFFLElBQUksQ0FFcEIsQ0FBQyxRQUFRLENBQUM7QUFDZCxNQUFNLFNBQVMsQ0FBQztBQUNoQixNQUFNLFNBQVMsQ0FBQztBQUNoQixNQUFNLGdCQUFnQixJQUFJO0FBQzFCLEtBQ0UsQ0FDQSw2REFBb0IsQ0FFbEIsT0FBTyxDQUFFLENBQUMsQ0FDVixVQUFVLENBQUUsVUFBVSxDQUN0QixVQUFVLENBQUUsSUFBSSxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FDNUMsVUFBVSxDQUFFLElBQUksQ0FDaEIsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsQ0FBQyxVQUFVLENBQUM7QUFDaEIsTUFBTSxTQUFTLEdBQUc7QUFDbEIsS0FDRSxDQUNBLFlBQVksc0RBQWEsQ0FDdkIsZ0JBQWdCLENBQUUsSUFBSSx5QkFBeUIsQ0FBQyxRQUFRLENBQzFELENBQ0EsWUFBWSxzREFBYSxDQUN2QixPQUFPLENBQUUsR0FBRyxDQUNaLE1BQU0sQ0FBRSxXQUNWLENBQ0EsWUFBWSw0REFBa0IsQ0FDOUIsc0RBQVksTUFBTSxDQUNsQixzREFBWSxPQUFRLENBQ2xCLGdCQUFnQixDQUFFLElBQUksdUJBQXVCLENBQUMsUUFBUSxDQUN4RCxDQUNBLDBEQUFpQixDQUNmLE9BQU8sQ0FBRSxJQUFJLG9CQUFvQixDQUFDLElBQUksQ0FDeEMsQ0FJQSxtQkFBbUIsd0JBQVUsQ0FBRyw0Q0FBaUIsQ0FDL0MsVUFBVSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUNqQyxZQUFZLENBQUUsSUFBSSxpQkFBaUIsQ0FBQyxLQUFLLENBQzNDLENBQ0Esd0RBQWUsQ0FDYixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxDQUFDLENBQ1QsZ0JBQWdCLENBQUUsT0FBTyxDQUN6QixVQUFVLENBQUUsVUFBVSxDQUN0QixPQUFPLENBQUUsSUFBSSxDQUNiLGVBQWUsQ0FBRSxhQUFhLENBQzlCLFdBQVcsQ0FBRSxNQUFNLENBQ25CLGFBQWEsQ0FBRSxLQUFLLElBQUksa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNyRCxPQUFPLENBQUUsSUFBSSxzQkFBc0IsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUVyRCxDQUFDLE1BQU07QUFDWCxJQUFJLENBQUMsT0FBTztBQUNaLElBQUksQ0FBQyxPQUFPLENBQUM7QUFDYixNQUFNLGtCQUFrQixJQUFJLHVCQUF1QixDQUFDLFFBQVEsQ0FBQztBQUM3RCxLQUFJLENBQ0EsQ0FBQyxPQUFPLFlBQVksQ0FBQztBQUN6QixNQUFNLFNBQVMsR0FBRztBQUNsQixNQUFNLGtCQUFrQixJQUFJLHVCQUF1QixDQUFDLFFBQVEsQ0FBQztBQUM3RCxLQUFJLENBQ0EsQ0FBQyxZQUFZLENBQUM7QUFDbEIsTUFBTSxTQUFTLEdBQUc7QUFDbEIsTUFBTSxRQUFRLFdBQVc7QUFDekIsS0FBSSxDQUVBLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO0FBQ3BCLE1BQU0sVUFBVSxRQUFRO0FBQ3hCLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDZCxRQUFRLE1BQU0sS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUM5QixPQUFNO0FBQ04sS0FDRSxDQUVBLG1EQUFVLENBQ1IsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixhQUFhLENBQUUsTUFDakIsQ0FDQSx1QkFBUyxDQUFHLCtCQUFJLENBQ1osTUFBTSxDQUFFLElBQUksc0JBQXNCLENBQUMsa0JBQWtCLENBQUMsQ0FDdEQsYUFBYSxDQUFFLElBQUksa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQzNDLE9BQU8sQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUNoQixNQUFNLENBQUUsSUFBSSxDQUFDLENBQUMsQ0FDZCxnQkFBZ0IsQ0FBRSxJQUFJLGtCQUFrQixDQUFDLEtBQUssQ0FDbEQsQ0FHQSwwREFBaUIsQ0FDZixRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsV0FBVyxDQUNwQixjQUFjLENBQUUsR0FBRyxDQUNuQixXQUFXLENBQUUsTUFBTSxDQUVuQixDQUFDLEtBQUssYUFBYSxDQUFDLENBQUM7QUFDekIsTUFBTSxVQUFVLFFBQVE7QUFDeEIsTUFBTSxnQkFBZ0IsSUFBSTtBQUMxQixLQUFJLENBRUEsQ0FBQyxNQUFNLENBQUM7QUFDWixNQUFNLFNBQVMsS0FBSyxVQUFVLENBQUMsQ0FBQyxHQUFHO0FBQ25DLE1BQU0sWUFBWSxNQUFNO0FBQ3hCLE1BQU0sYUFBYSxRQUFRO0FBQzNCLEtBQ0UsQ0FDQSx3QkFBVSxDQUFDLHVDQUFXLEtBQUssTUFBTSxDQUFFLENBQ2pDLEtBQUssQ0FBRSxXQUNULENBQ0EseUJBQVcsQ0FBQyxVQUFVLFVBQVUsd0JBQVUsQ0FBRyxpQ0FBb0IsQ0FDL0QsT0FBTyxDQUFFLEdBQ1gsQ0FDQSwwREFBZ0IsTUFBTSxDQUN0Qix5REFBZ0IsQ0FDZCxLQUFLLENBQUUsSUFBSSxDQUNYLFNBQVMsQ0FBRSxHQUFHLENBQ2QsU0FBUyxDQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNoQixJQUFJLENBQUUsT0FBTyxDQUNiLE9BQU8sQ0FBRSxDQUFDLENBQUMsTUFBTSxDQUNqQixNQUFNLENBQUUsQ0FBQyxDQUNULE1BQU0sQ0FBRSxJQUFJLENBQ1osVUFBVSxDQUFFLElBQUksQ0FDaEIsVUFBVSxDQUFFLElBQUksQ0FDaEIsTUFBTSxDQUFFLElBQ1YsQ0FDQSx3QkFBVSxDQUFDLDJDQUFnQixDQUN6QixZQUFZLENBQUUsQ0FBQyxDQUNmLFdBQVcsQ0FBRSxJQUNmLENBRUEseURBQWdCLENBQ2QsT0FBTyxDQUFFLElBQUksQ0FDYixDQUFDLFlBQVksQ0FBQztBQUNsQixNQUFNLE9BQU8sSUFBSSxzQkFBc0IsQ0FBQyxRQUFRLENBQUM7QUFDakQsS0FDRSIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiU3ZlbGVjdGUuc3ZlbHRlIl19 */`);
}
var get_create_row_slot_changes = (dirty) => ({
  isCreating: dirty[1] & /*isCreating*/
  8,
  inputValue: dirty[0] & /*input_value*/
  4194304,
  i18n: dirty[0] & /*i18n_actual*/
  8388608
});
var get_create_row_slot_context = (ctx) => ({
  isCreating: (
    /*isCreating*/
    ctx[34]
  ),
  inputValue: (
    /*input_value*/
    ctx[22]
  ),
  i18n: (
    /*i18n_actual*/
    ctx[23]
  )
});
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[163] = list[i];
  child_ctx[165] = i;
  return child_ctx;
}
var get_option_slot_changes_1 = (dirty) => ({
  item: dirty[0] & /*options_filtered*/
  16777216
});
var get_option_slot_context_1 = (ctx) => ({ item: (
  /*opt*/
  ctx[163]
) });
function get_context(ctx) {
  const constants_0 = (
    /*options_filtered*/
    ctx[24][
      /*index*/
      ctx[162]
    ]
  );
  ctx[163] = constants_0;
}
var get_option_slot_changes = (dirty) => ({
  item: dirty[0] & /*options_filtered*/
  16777216 | dirty[5] & /*index*/
  128
});
var get_option_slot_context = (ctx) => ({ item: (
  /*opt*/
  ctx[163]
) });
var get_list_header_slot_changes = (dirty) => ({});
var get_list_header_slot_context = (ctx) => ({});
var get_control_end_slot_changes = (dirty) => ({});
var get_control_end_slot_context = (ctx) => ({});
var get_dropdown_toggle_slot_changes = (dirty) => ({
  isOpen: dirty[0] & /*is_dropdown_opened*/
  524288
});
var get_dropdown_toggle_slot_context = (ctx) => ({ isOpen: (
  /*is_dropdown_opened*/
  ctx[19]
) });
var get_clear_icon_slot_changes = (dirty) => ({
  selectedOptions: dirty[0] & /*selectedOptions*/
  262144,
  inputValue: dirty[0] & /*input_value*/
  4194304
});
var get_clear_icon_slot_context = (ctx) => ({
  selectedOptions: (
    /*selectedOptions*/
    ctx[18]
  ),
  inputValue: (
    /*input_value*/
    ctx[22]
  )
});
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[163] = list[i];
  return child_ctx;
}
var get_selection_slot_changes = (dirty) => ({
  selectedOptions: dirty[0] & /*selectedOptions*/
  262144
});
var get_selection_slot_context = (ctx) => ({
  selectedOptions: (
    /*selectedOptions*/
    ctx[18]
  ),
  bindItem
});
var get_collapsedSelection_slot_changes = (dirty) => ({
  selectedOptions: dirty[0] & /*selectedOptions*/
  262144,
  i18n: dirty[0] & /*i18n_actual*/
  8388608
});
var get_collapsedSelection_slot_context = (ctx) => ({
  selectedOptions: (
    /*selectedOptions*/
    ctx[18]
  ),
  i18n: (
    /*i18n_actual*/
    ctx[23]
  )
});
var get_icon_slot_changes = (dirty) => ({});
var get_icon_slot_context = (ctx) => ({});
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[163] = list[i];
  return child_ctx;
}
function create_if_block_14(ctx) {
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = text(
        /*aria_selection*/
        ctx[45]
      );
      t1 = space();
      span1 = element("span");
      t2 = text(
        /*aria_context*/
        ctx[44]
      );
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", { id: true });
      var span0_nodes = children(span0);
      t0 = claim_text(
        span0_nodes,
        /*aria_selection*/
        ctx[45]
      );
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", { id: true });
      var span1_nodes = children(span1);
      t2 = claim_text(
        span1_nodes,
        /*aria_context*/
        ctx[44]
      );
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "id", "aria-selection");
      add_location(span0, file2, 1718, 8, 52324);
      attr_dev(span1, "id", "aria-context");
      add_location(span1, file2, 1719, 8, 52382);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      append_hydration_dev(span0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty[1] & /*aria_selection*/
      16384)
        set_data_dev(
          t0,
          /*aria_selection*/
          ctx2[45]
        );
      if (dirty[1] & /*aria_context*/
      8192)
        set_data_dev(
          t2,
          /*aria_context*/
          ctx2[44]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span0);
        detach_dev(t1);
        detach_dev(span1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(1718:4) {#if is_focused}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let select;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let svelte_use_form_validator_action;
  let mounted;
  let dispose;
  let each_value_2 = ensure_array_like_dev(
    /*selectedOptions*/
    ctx[18]
  );
  const get_key = (ctx2) => (
    /*opt*/
    ctx2[163][
      /*currentValueField*/
      ctx2[26]
    ]
  );
  validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
  for (let i = 0; i < each_value_2.length; i += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
  }
  const block = {
    c: function create() {
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      select = claim_element(nodes, "SELECT", {
        name: true,
        size: true,
        class: true,
        id: true,
        tabindex: true,
        "aria-hidden": true
      });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(
        select,
        "name",
        /*name*/
        ctx[4]
      );
      select.required = /*required*/
      ctx[5];
      select.multiple = /*multiple*/
      ctx[0];
      select.disabled = /*disabled*/
      ctx[3];
      attr_dev(select, "size", "1");
      attr_dev(select, "class", "sv-hidden-element");
      attr_dev(
        select,
        "id",
        /*DOM_ID*/
        ctx[49]
      );
      attr_dev(select, "tabindex", "-1");
      attr_dev(select, "aria-hidden", "true");
      add_location(select, file2, 1723, 2, 52482);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, select, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      ctx[110](select);
      if (!mounted) {
        dispose = action_destroyer(svelte_use_form_validator_action = /*svelte_use_form_validator*/
        ctx[59].call(
          null,
          select,
          /*validatorAction*/
          ctx[13]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*selectedOptions, currentValueField*/
      67371008) {
        each_value_2 = ensure_array_like_dev(
          /*selectedOptions*/
          ctx2[18]
        );
        validate_each_keys(ctx2, each_value_2, get_each_context_2, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, select, destroy_block, create_each_block_2, null, get_each_context_2);
      }
      if (dirty[0] & /*name*/
      16) {
        attr_dev(
          select,
          "name",
          /*name*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*required*/
      32) {
        prop_dev(
          select,
          "required",
          /*required*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*multiple*/
      1) {
        prop_dev(
          select,
          "multiple",
          /*multiple*/
          ctx2[0]
        );
      }
      if (dirty[0] & /*disabled*/
      8) {
        prop_dev(
          select,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (svelte_use_form_validator_action && is_function(svelte_use_form_validator_action.update) && dirty[0] & /*validatorAction*/
      8192)
        svelte_use_form_validator_action.update.call(
          null,
          /*validatorAction*/
          ctx2[13]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(select);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      ctx[110](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(1723:2) {#if name && !anchor_element}",
    ctx
  });
  return block;
}
function create_each_block_2(key_1, ctx) {
  let option;
  let option_value_value;
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      option = element("option");
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      children(option).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*opt*/
      ctx[163][
        /*currentValueField*/
        ctx[26]
      ];
      set_input_value(option, option.__value);
      option.selected = true;
      add_location(option, file2, 1728, 4, 52765);
      this.first = option;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*selectedOptions, currentValueField*/
      67371008 && option_value_value !== (option_value_value = /*opt*/
      ctx[163][
        /*currentValueField*/
        ctx[26]
      ])) {
        prop_dev(option, "__value", option_value_value);
        set_input_value(option, option.__value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(1728:4) {#each selectedOptions as opt (opt[currentValueField])}",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_11, create_else_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*multiple*/
      ctx2[0] && /*doCollapse*/
      ctx2[32]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(1744:6) {#if selectedOptions.length }",
    ctx
  });
  return block;
}
function create_else_block_3(ctx) {
  let current;
  const selection_slot_template = (
    /*#slots*/
    ctx[107].selection
  );
  const selection_slot = create_slot(
    selection_slot_template,
    ctx,
    /*$$scope*/
    ctx[116],
    get_selection_slot_context
  );
  const selection_slot_or_fallback = selection_slot || fallback_block_6(ctx);
  const block = {
    c: function create() {
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (selection_slot_or_fallback) {
        selection_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (selection_slot) {
        if (selection_slot.p && (!current || dirty[0] & /*selectedOptions*/
        262144 | dirty[3] & /*$$scope*/
        8388608)) {
          update_slot_base(
            selection_slot,
            selection_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[116],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[116]
            ) : get_slot_changes(
              selection_slot_template,
              /*$$scope*/
              ctx2[116],
              dirty,
              get_selection_slot_changes
            ),
            get_selection_slot_context
          );
        }
      } else {
        if (selection_slot_or_fallback && selection_slot_or_fallback.p && (!current || dirty[0] & /*selectedOptions, multiple*/
        262145 | dirty[1] & /*itemRenderer*/
        4096)) {
          selection_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(selection_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(selection_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (selection_slot_or_fallback)
        selection_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_3.name,
    type: "else",
    source: "(1747:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let current;
  const collapsedSelection_slot_template = (
    /*#slots*/
    ctx[107].collapsedSelection
  );
  const collapsedSelection_slot = create_slot(
    collapsedSelection_slot_template,
    ctx,
    /*$$scope*/
    ctx[116],
    get_collapsedSelection_slot_context
  );
  const collapsedSelection_slot_or_fallback = collapsedSelection_slot || fallback_block_5(ctx);
  const block = {
    c: function create() {
      if (collapsedSelection_slot_or_fallback)
        collapsedSelection_slot_or_fallback.c();
    },
    l: function claim(nodes) {
      if (collapsedSelection_slot_or_fallback)
        collapsedSelection_slot_or_fallback.l(nodes);
    },
    m: function mount(target, anchor) {
      if (collapsedSelection_slot_or_fallback) {
        collapsedSelection_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (collapsedSelection_slot) {
        if (collapsedSelection_slot.p && (!current || dirty[0] & /*selectedOptions, i18n_actual*/
        8650752 | dirty[3] & /*$$scope*/
        8388608)) {
          update_slot_base(
            collapsedSelection_slot,
            collapsedSelection_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[116],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[116]
            ) : get_slot_changes(
              collapsedSelection_slot_template,
              /*$$scope*/
              ctx2[116],
              dirty,
              get_collapsedSelection_slot_changes
            ),
            get_collapsedSelection_slot_context
          );
        }
      } else {
        if (collapsedSelection_slot_or_fallback && collapsedSelection_slot_or_fallback.p && (!current || dirty[0] & /*i18n_actual, selectedOptions*/
        8650752)) {
          collapsedSelection_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1, -1, -1] : dirty);
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(collapsedSelection_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(collapsedSelection_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (collapsedSelection_slot_or_fallback)
        collapsedSelection_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(1745:6) {#if multiple && doCollapse}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let button;
  let svg;
  let path;
  let bindItem_action;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        tabindex: true,
        type: true,
        "data-action": true
      });
      var button_nodes = children(button);
      svg = claim_svg_element(button_nodes, "svg", {
        height: true,
        width: true,
        viewBox: true,
        "aria-hidden": true,
        focusable: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z");
      add_location(path, file2, 1761, 16, 54402);
      attr_dev(svg, "height", "16");
      attr_dev(svg, "width", "16");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "focusable", "false");
      add_location(svg, file2, 1760, 14, 54300);
      attr_dev(button, "class", "sv-item--btn");
      attr_dev(button, "tabindex", "-1");
      attr_dev(button, "type", "button");
      attr_dev(button, "data-action", "deselect");
      add_location(button, file2, 1756, 12, 54145);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, svg);
      append_hydration_dev(svg, path);
      if (!mounted) {
        dispose = action_destroyer(bindItem_action = bindItem.call(
          null,
          button,
          /*opt*/
          ctx[163]
        ));
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (bindItem_action && is_function(bindItem_action.update) && dirty[0] & /*selectedOptions*/
      262144)
        bindItem_action.update.call(
          null,
          /*opt*/
          ctx[163]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(1756:12) {#if multiple}",
    ctx
  });
  return block;
}
function create_each_block_1(key_1, ctx) {
  let div2;
  let div1;
  let div0;
  let html_tag;
  let raw_value = (
    /*itemRenderer*/
    ctx[43](
      /*opt*/
      ctx[163],
      true
    ) + ""
  );
  let t0;
  let t1;
  let rect;
  let stop_animation = noop;
  let mounted;
  let dispose;
  let if_block = (
    /*multiple*/
    ctx[0] && create_if_block_12(ctx)
  );
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      html_tag = new HtmlTagHydration(false);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      html_tag = claim_html_tag(div0_nodes, false);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      if (if_block)
        if_block.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(div0, "class", "sv-item--content");
      add_location(div0, file2, 1753, 14, 54019);
      attr_dev(div1, "class", "sv-item--wrap");
      toggle_class(
        div1,
        "is-multi",
        /*multiple*/
        ctx[0]
      );
      add_location(div1, file2, 1752, 12, 53951);
      attr_dev(div2, "class", "sv-item--container svelte-hi60qz");
      add_location(div2, file2, 1749, 10, 53812);
      this.first = div2;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      html_tag.m(raw_value, div0);
      append_hydration_dev(div2, t0);
      if (if_block)
        if_block.m(div2, null);
      append_hydration_dev(div2, t1);
      if (!mounted) {
        dispose = listen_dev(div2, "mousedown", prevent_default(
          /*mousedown_handler*/
          ctx[109]
        ), false, true, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*selectedOptions*/
      262144 | dirty[1] & /*itemRenderer*/
      4096 && raw_value !== (raw_value = /*itemRenderer*/
      ctx[43](
        /*opt*/
        ctx[163],
        true
      ) + ""))
        html_tag.p(raw_value);
      if (dirty[0] & /*multiple*/
      1) {
        toggle_class(
          div1,
          "is-multi",
          /*multiple*/
          ctx[0]
        );
      }
      if (
        /*multiple*/
        ctx[0]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_12(ctx);
          if_block.c();
          if_block.m(div2, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    r: function measure() {
      rect = div2.getBoundingClientRect();
    },
    f: function fix() {
      fix_position(div2);
      stop_animation();
    },
    a: function animate() {
      stop_animation();
      stop_animation = create_animation(div2, rect, flip, { duration: (
        /*flipDurationMs*/
        ctx[35]
      ) });
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(1749:10) {#each selectedOptions as opt (opt[currentValueField])}",
    ctx
  });
  return block;
}
function fallback_block_6(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value_1 = ensure_array_like_dev(
    /*selectedOptions*/
    ctx[18]
  );
  const get_key = (ctx2) => (
    /*opt*/
    ctx2[163][
      /*currentValueField*/
      ctx2[26]
    ]
  );
  validate_each_keys(ctx, each_value_1, get_each_context_1, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*selectedOptions, multiple, currentValueField*/
      67371009 | dirty[1] & /*itemRenderer*/
      4096) {
        each_value_1 = ensure_array_like_dev(
          /*selectedOptions*/
          ctx2[18]
        );
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        validate_each_keys(ctx2, each_value_1, get_each_context_1, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, fix_and_destroy_block, create_each_block_1, each_1_anchor, get_each_context_1);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_6.name,
    type: "fallback",
    source: "(1748:60)            ",
    ctx
  });
  return block;
}
function fallback_block_5(ctx) {
  let t_value = (
    /*i18n_actual*/
    ctx[23].collapsedSelection(
      /*selectedOptions*/
      ctx[18].length
    ) + ""
  );
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*i18n_actual, selectedOptions*/
      8650752 && t_value !== (t_value = /*i18n_actual*/
      ctx2[23].collapsedSelection(
        /*selectedOptions*/
        ctx2[18].length
      ) + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_5.name,
    type: "fallback",
    source: "(1746:77) {i18n_actual.collapsedSelection(selectedOptions.length)}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let button;
  let current;
  const clear_icon_slot_template = (
    /*#slots*/
    ctx[107]["clear-icon"]
  );
  const clear_icon_slot = create_slot(
    clear_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[116],
    get_clear_icon_slot_context
  );
  const clear_icon_slot_or_fallback = clear_icon_slot || fallback_block_4(ctx);
  const block = {
    c: function create() {
      button = element("button");
      if (clear_icon_slot_or_fallback)
        clear_icon_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        type: true,
        class: true,
        "data-action": true,
        tabindex: true
      });
      var button_nodes = children(button);
      if (clear_icon_slot_or_fallback)
        clear_icon_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "sv-btn-indicator svelte-hi60qz");
      attr_dev(button, "data-action", "deselect");
      attr_dev(button, "tabindex", "-1");
      toggle_class(
        button,
        "sv-has-selection",
        /*selectedOptions*/
        ctx[18].length
      );
      add_location(button, file2, 1797, 6, 56013);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      if (clear_icon_slot_or_fallback) {
        clear_icon_slot_or_fallback.m(button, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (clear_icon_slot) {
        if (clear_icon_slot.p && (!current || dirty[0] & /*selectedOptions, input_value*/
        4456448 | dirty[3] & /*$$scope*/
        8388608)) {
          update_slot_base(
            clear_icon_slot,
            clear_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[116],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[116]
            ) : get_slot_changes(
              clear_icon_slot_template,
              /*$$scope*/
              ctx2[116],
              dirty,
              get_clear_icon_slot_changes
            ),
            get_clear_icon_slot_context
          );
        }
      } else {
        if (clear_icon_slot_or_fallback && clear_icon_slot_or_fallback.p && (!current || dirty[0] & /*selectedOptions*/
        262144)) {
          clear_icon_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*selectedOptions*/
      262144) {
        toggle_class(
          button,
          "sv-has-selection",
          /*selectedOptions*/
          ctx2[18].length
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(clear_icon_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(clear_icon_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(button);
      }
      if (clear_icon_slot_or_fallback)
        clear_icon_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(1797:6) {#if clearable && !disabled}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        viewBox: true,
        "aria-hidden": true,
        focusable: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z");
      add_location(path, file2, 1802, 95, 56372);
      attr_dev(svg, "class", "indicator-icon svelte-hi60qz");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "focusable", "false");
      add_location(svg, file2, 1802, 10, 56287);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(1802:10) {#if selectedOptions.length}",
    ctx
  });
  return block;
}
function fallback_block_4(ctx) {
  let if_block_anchor;
  let if_block = (
    /*selectedOptions*/
    ctx[18].length && create_if_block_9(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (
        /*selectedOptions*/
        ctx2[18].length
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block_9(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_4.name,
    type: "fallback",
    source: "(1801:75)            ",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "sv-btn-separator svelte-hi60qz");
      add_location(span, file2, 1807, 21, 56824);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(1808:6) {#if clearable}",
    ctx
  });
  return block;
}
function fallback_block_3(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        viewBox: true,
        "aria-hidden": true,
        focusable: true
      });
      var svg_nodes = children(svg);
      path = claim_svg_element(svg_nodes, "path", { d: true });
      children(path).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
      add_location(path, file2, 1813, 12, 57192);
      attr_dev(svg, "class", "indicator-icon svelte-hi60qz");
      attr_dev(svg, "viewBox", "0 0 20 20");
      attr_dev(svg, "aria-hidden", "true");
      attr_dev(svg, "focusable", "false");
      add_location(svg, file2, 1812, 10, 57094);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      append_hydration_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(svg);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_3.name,
    type: "fallback",
    source: "(1812:65)            ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let t0;
  let div1;
  let div0;
  let current_block_type_index;
  let if_block0;
  let t1;
  let if_block1_anchor;
  let current;
  const list_header_slot_template = (
    /*#slots*/
    ctx[107]["list-header"]
  );
  const list_header_slot = create_slot(
    list_header_slot_template,
    ctx,
    /*$$scope*/
    ctx[116],
    get_list_header_slot_context
  );
  const if_block_creators = [create_if_block_2, create_if_block_6];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*options_filtered*/
      ctx2[24].length
    )
      return 0;
    if (
      /*options_filtered*/
      ctx2[24].length === 0 && (!/*creatable*/
      ctx2[14] || !/*input_value*/
      ctx2[22]) || /*maxReached*/
      ctx2[25]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1, -1, -1]))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*creatable*/
    ctx[14] && /*input_value*/
    ctx[22] && !/*maxReached*/
    ctx[25] && create_if_block_1(ctx)
  );
  const block = {
    c: function create() {
      if (list_header_slot)
        list_header_slot.c();
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      if (list_header_slot)
        list_header_slot.l(nodes);
      t0 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { class: true, tabindex: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block0)
        if_block0.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "sv-dropdown-content");
      toggle_class(
        div0,
        "max-reached",
        /*maxReached*/
        ctx[25]
      );
      add_location(div0, file2, 1831, 8, 58122);
      attr_dev(div1, "class", "sv-dropdown-scroll svelte-hi60qz");
      attr_dev(div1, "tabindex", "-1");
      toggle_class(
        div1,
        "has-items",
        /*options_filtered*/
        ctx[24].length > 0
      );
      toggle_class(
        div1,
        "is-virtual",
        /*virtualList*/
        ctx[15]
      );
      add_location(div1, file2, 1830, 6, 57959);
    },
    m: function mount(target, anchor) {
      if (list_header_slot) {
        list_header_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div0, null);
      }
      ctx[114](div0);
      ctx[115](div1);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (list_header_slot) {
        if (list_header_slot.p && (!current || dirty[3] & /*$$scope*/
        8388608)) {
          update_slot_base(
            list_header_slot,
            list_header_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[116],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[116]
            ) : get_slot_changes(
              list_header_slot_template,
              /*$$scope*/
              ctx2[116],
              dirty,
              get_list_header_slot_changes
            ),
            get_list_header_slot_context
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        } else {
          if_block0 = null;
        }
      }
      if (!current || dirty[0] & /*maxReached*/
      33554432) {
        toggle_class(
          div0,
          "max-reached",
          /*maxReached*/
          ctx2[25]
        );
      }
      if (!current || dirty[0] & /*options_filtered*/
      16777216) {
        toggle_class(
          div1,
          "has-items",
          /*options_filtered*/
          ctx2[24].length > 0
        );
      }
      if (!current || dirty[0] & /*virtualList*/
      32768) {
        toggle_class(
          div1,
          "is-virtual",
          /*virtualList*/
          ctx2[15]
        );
      }
      if (
        /*creatable*/
        ctx2[14] && /*input_value*/
        ctx2[22] && !/*maxReached*/
        ctx2[25]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*creatable, input_value, maxReached*/
          37765120) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list_header_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(list_header_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(div1);
        detach_dev(t1);
        detach_dev(if_block1_anchor);
      }
      if (list_header_slot)
        list_header_slot.d(detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[114](null);
      ctx[115](null);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(1829:2) {#if is_mounted && render_dropdown}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let div2;
  let div1;
  let div0;
  let t;
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      t = text(
        /*listMessage*/
        ctx[41]
      );
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t = claim_text(
        div0_nodes,
        /*listMessage*/
        ctx[41]
      );
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "sv-item--content");
      add_location(div0, file2, 1884, 39, 60494);
      attr_dev(div1, "class", "sv-item--wrap");
      add_location(div1, file2, 1884, 12, 60467);
      attr_dev(div2, "class", "is-dropdown-row svelte-hi60qz");
      add_location(div2, file2, 1883, 10, 60425);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[1] & /*listMessage*/
      1024)
        set_data_dev(
          t,
          /*listMessage*/
          ctx2[41]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(1883:94) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3, create_else_block_1];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*virtualList*/
      ctx2[15]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_2(ctx, [-1, -1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(1833:8) {#if options_filtered.length}",
    ctx
  });
  return block;
}
function create_else_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*options_filtered*/
    ctx[24]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*options_filtered, dropdown_index, disabledField, input_value, disableHighlight*/
      22021248 | dirty[1] & /*itemRenderer*/
      4096 | dirty[3] & /*$$scope*/
      8388608) {
        each_value = ensure_array_like_dev(
          /*options_filtered*/
          ctx2[24]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(1863:10) {:else}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let tinyvirtuallist;
  let current;
  let tinyvirtuallist_props = {
    width: "100%",
    height: (
      /*vl_listHeight*/
      ctx[48]
    ),
    itemCount: (
      /*options_filtered*/
      ctx[24].length
    ),
    itemSize: (
      /*vl_itemSize*/
      ctx[21]
    ),
    scrollToAlignment: "auto",
    scrollToIndex: (
      /*dropdown_index*/
      ctx[20]
    ),
    $$slots: {
      item: [
        create_item_slot,
        ({ style, index }) => ({ 161: style, 162: index }),
        ({ style, index }) => [0, 0, 0, 0, 0, (style ? 64 : 0) | (index ? 128 : 0)]
      ]
    },
    $$scope: { ctx }
  };
  tinyvirtuallist = new VirtualList_default({
    props: tinyvirtuallist_props,
    $$inline: true
  });
  ctx[113](tinyvirtuallist);
  const block = {
    c: function create() {
      create_component(tinyvirtuallist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tinyvirtuallist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tinyvirtuallist, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tinyvirtuallist_changes = {};
      if (dirty[1] & /*vl_listHeight*/
      131072)
        tinyvirtuallist_changes.height = /*vl_listHeight*/
        ctx2[48];
      if (dirty[0] & /*options_filtered*/
      16777216)
        tinyvirtuallist_changes.itemCount = /*options_filtered*/
        ctx2[24].length;
      if (dirty[0] & /*vl_itemSize*/
      2097152)
        tinyvirtuallist_changes.itemSize = /*vl_itemSize*/
        ctx2[21];
      if (dirty[0] & /*dropdown_index*/
      1048576)
        tinyvirtuallist_changes.scrollToIndex = /*dropdown_index*/
        ctx2[20];
      if (dirty[0] & /*options_filtered, dropdown_index, disabledField, input_value, disableHighlight*/
      22021248 | dirty[1] & /*itemRenderer*/
      4096 | dirty[3] & /*$$scope*/
      8388608 | dirty[5] & /*style, index*/
      192) {
        tinyvirtuallist_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tinyvirtuallist.$set(tinyvirtuallist_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tinyvirtuallist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tinyvirtuallist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[113](null);
      destroy_component(tinyvirtuallist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(1834:10) {#if virtualList}",
    ctx
  });
  return block;
}
function create_else_block_2(ctx) {
  let div;
  let t;
  let div_data_pos_value;
  let current;
  const option_slot_template = (
    /*#slots*/
    ctx[107].option
  );
  const option_slot = create_slot(
    option_slot_template,
    ctx,
    /*$$scope*/
    ctx[116],
    get_option_slot_context_1
  );
  const option_slot_or_fallback = option_slot || fallback_block_2(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (option_slot_or_fallback)
        option_slot_or_fallback.c();
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-pos": true, class: true });
      var div_nodes = children(div);
      if (option_slot_or_fallback)
        option_slot_or_fallback.l(div_nodes);
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "data-pos", div_data_pos_value = /*i*/
      ctx[165]);
      attr_dev(div, "class", "sv-item--wrap in-dropdown svelte-hi60qz");
      toggle_class(
        div,
        "sv-dd-item-active",
        /*dropdown_index*/
        ctx[20] === /*i*/
        ctx[165]
      );
      toggle_class(
        div,
        "is-selected",
        /*opt*/
        ctx[163].$selected
      );
      toggle_class(
        div,
        "is-disabled",
        /*opt*/
        ctx[163][
          /*disabledField*/
          ctx[7]
        ]
      );
      add_location(div, file2, 1867, 16, 59721);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (option_slot_or_fallback) {
        option_slot_or_fallback.m(div, null);
      }
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (option_slot) {
        if (option_slot.p && (!current || dirty[0] & /*options_filtered*/
        16777216 | dirty[3] & /*$$scope*/
        8388608)) {
          update_slot_base(
            option_slot,
            option_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[116],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[116]
            ) : get_slot_changes(
              option_slot_template,
              /*$$scope*/
              ctx2[116],
              dirty,
              get_option_slot_changes_1
            ),
            get_option_slot_context_1
          );
        }
      } else {
        if (option_slot_or_fallback && option_slot_or_fallback.p && (!current || dirty[0] & /*options_filtered, input_value, disableHighlight*/
        20972544 | dirty[1] & /*itemRenderer*/
        4096)) {
          option_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*dropdown_index*/
      1048576) {
        toggle_class(
          div,
          "sv-dd-item-active",
          /*dropdown_index*/
          ctx2[20] === /*i*/
          ctx2[165]
        );
      }
      if (!current || dirty[0] & /*options_filtered*/
      16777216) {
        toggle_class(
          div,
          "is-selected",
          /*opt*/
          ctx2[163].$selected
        );
      }
      if (!current || dirty[0] & /*options_filtered, disabledField*/
      16777344) {
        toggle_class(
          div,
          "is-disabled",
          /*opt*/
          ctx2[163][
            /*disabledField*/
            ctx2[7]
          ]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(option_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(option_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (option_slot_or_fallback)
        option_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_2.name,
    type: "else",
    source: "(1867:14) {:else}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let div;
  let b;
  let t_value = (
    /*opt*/
    ctx[163].label + ""
  );
  let t;
  const block = {
    c: function create() {
      div = element("div");
      b = element("b");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      b = claim_element(div_nodes, "B", {});
      var b_nodes = children(b);
      t = claim_text(b_nodes, t_value);
      b_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(b, file2, 1865, 48, 59658);
      attr_dev(div, "class", "sv-optgroup-header");
      add_location(div, file2, 1865, 16, 59626);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, b);
      append_hydration_dev(b, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*options_filtered*/
      16777216 && t_value !== (t_value = /*opt*/
      ctx2[163].label + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(1865:14) {#if opt.$isGroupHeader}",
    ctx
  });
  return block;
}
function fallback_block_2(ctx) {
  let div;
  let html_tag;
  let raw_value = highlightSearch(
    /*opt*/
    ctx[163],
    false,
    /*input_value*/
    ctx[22],
    /*itemRenderer*/
    ctx[43],
    /*disableHighlight*/
    ctx[10]
  ) + "";
  const block = {
    c: function create() {
      div = element("div");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      html_tag = claim_html_tag(div_nodes, false);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(div, "class", "sv-item--content");
      add_location(div, file2, 1874, 20, 60053);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      html_tag.m(raw_value, div);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*options_filtered, input_value, disableHighlight*/
      20972544 | dirty[1] & /*itemRenderer*/
      4096 && raw_value !== (raw_value = highlightSearch(
        /*opt*/
        ctx2[163],
        false,
        /*input_value*/
        ctx2[22],
        /*itemRenderer*/
        ctx2[43],
        /*disableHighlight*/
        ctx2[10]
      ) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_2.name,
    type: "fallback",
    source: "(1874:49)                      ",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5, create_else_block_2];
  const if_blocks = [];
  function select_block_type_4(ctx2, dirty) {
    if (
      /*opt*/
      ctx2[163].$isGroupHeader
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_4(ctx, [-1, -1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(1864:12) {#each options_filtered as opt, i}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let div;
  let div_data_pos_value;
  let current;
  const option_slot_template = (
    /*#slots*/
    ctx[107].option
  );
  const option_slot = create_slot(
    option_slot_template,
    ctx,
    /*$$scope*/
    ctx[116],
    get_option_slot_context
  );
  const option_slot_or_fallback = option_slot || fallback_block_1(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (option_slot_or_fallback)
        option_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-pos": true, class: true });
      var div_nodes = children(div);
      if (option_slot_or_fallback)
        option_slot_or_fallback.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "data-pos", div_data_pos_value = /*index*/
      ctx[162]);
      attr_dev(div, "class", "sv-item--wrap in-dropdown svelte-hi60qz");
      toggle_class(
        div,
        "sv-dd-item-active",
        /*dropdown_index*/
        ctx[20] === /*index*/
        ctx[162]
      );
      toggle_class(
        div,
        "is-selected",
        /*opt*/
        ctx[163].$selected
      );
      toggle_class(
        div,
        "is-disabled",
        /*opt*/
        ctx[163][
          /*disabledField*/
          ctx[7]
        ]
      );
      add_location(div, file2, 1847, 18, 58859);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (option_slot_or_fallback) {
        option_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (option_slot) {
        if (option_slot.p && (!current || dirty[0] & /*options_filtered*/
        16777216 | dirty[3] & /*$$scope*/
        8388608 | dirty[5] & /*index*/
        128)) {
          update_slot_base(
            option_slot,
            option_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[116],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[116]
            ) : get_slot_changes(
              option_slot_template,
              /*$$scope*/
              ctx2[116],
              dirty,
              get_option_slot_changes
            ),
            get_option_slot_context
          );
        }
      } else {
        if (option_slot_or_fallback && option_slot_or_fallback.p && (!current || dirty[0] & /*options_filtered, input_value, disableHighlight*/
        20972544 | dirty[1] & /*itemRenderer*/
        4096 | dirty[5] & /*index*/
        128)) {
          option_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[5] & /*index*/
      128 && div_data_pos_value !== (div_data_pos_value = /*index*/
      ctx2[162])) {
        attr_dev(div, "data-pos", div_data_pos_value);
      }
      if (!current || dirty[0] & /*dropdown_index*/
      1048576 | dirty[5] & /*index*/
      128) {
        toggle_class(
          div,
          "sv-dd-item-active",
          /*dropdown_index*/
          ctx2[20] === /*index*/
          ctx2[162]
        );
      }
      if (!current || dirty[0] & /*options_filtered*/
      16777216 | dirty[5] & /*index*/
      128) {
        toggle_class(
          div,
          "is-selected",
          /*opt*/
          ctx2[163].$selected
        );
      }
      if (!current || dirty[0] & /*options_filtered, disabledField*/
      16777344 | dirty[5] & /*index*/
      128) {
        toggle_class(
          div,
          "is-disabled",
          /*opt*/
          ctx2[163][
            /*disabledField*/
            ctx2[7]
          ]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(option_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(option_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (option_slot_or_fallback)
        option_slot_or_fallback.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(1847:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let div;
  let b;
  let t_value = (
    /*opt*/
    ctx[163].label + ""
  );
  let t;
  const block = {
    c: function create() {
      div = element("div");
      b = element("b");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      b = claim_element(div_nodes, "B", {});
      var b_nodes = children(b);
      t = claim_text(b_nodes, t_value);
      b_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(b, file2, 1845, 50, 58792);
      attr_dev(div, "class", "sv-optgroup-header");
      add_location(div, file2, 1845, 18, 58760);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, b);
      append_hydration_dev(b, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*options_filtered*/
      16777216 | dirty[5] & /*index*/
      128 && t_value !== (t_value = /*opt*/
      ctx2[163].label + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(1845:16) {#if opt.$isGroupHeader}",
    ctx
  });
  return block;
}
function fallback_block_1(ctx) {
  let div;
  let html_tag;
  let raw_value = highlightSearch(
    /*opt*/
    ctx[163],
    false,
    /*input_value*/
    ctx[22],
    /*itemRenderer*/
    ctx[43],
    /*disableHighlight*/
    ctx[10]
  ) + "";
  const block = {
    c: function create() {
      div = element("div");
      html_tag = new HtmlTagHydration(false);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      html_tag = claim_html_tag(div_nodes, false);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      html_tag.a = null;
      attr_dev(div, "class", "sv-item--content");
      add_location(div, file2, 1854, 22, 59213);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      html_tag.m(raw_value, div);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*options_filtered, input_value, disableHighlight*/
      20972544 | dirty[1] & /*itemRenderer*/
      4096 | dirty[5] & /*index*/
      128 && raw_value !== (raw_value = highlightSearch(
        /*opt*/
        ctx2[163],
        false,
        /*input_value*/
        ctx2[22],
        /*itemRenderer*/
        ctx2[43],
        /*disableHighlight*/
        ctx2[10]
      ) + ""))
        html_tag.p(raw_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block_1.name,
    type: "fallback",
    source: "(1854:51)                        ",
    ctx
  });
  return block;
}
function create_item_slot(ctx) {
  get_context(ctx);
  let div;
  let current_block_type_index;
  let if_block;
  let div_style_value;
  let current;
  const if_block_creators = [create_if_block_4, create_else_block];
  const if_blocks = [];
  function select_block_type_3(ctx2, dirty) {
    if (
      /*opt*/
      ctx2[163].$isGroupHeader
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_3(ctx, [-1, -1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { slot: true, style: true });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "slot", "item");
      attr_dev(div, "style", div_style_value = /*style*/
      ctx[161]);
      add_location(div, file2, 1842, 14, 58600);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      get_context(ctx2);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty[5] & /*style*/
      64 && div_style_value !== (div_style_value = /*style*/
      ctx2[161])) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_slot.name,
    type: "slot",
    source: "(1843:14) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let button;
  let current;
  let mounted;
  let dispose;
  const create_row_slot_template = (
    /*#slots*/
    ctx[107]["create-row"]
  );
  const create_row_slot = create_slot(
    create_row_slot_template,
    ctx,
    /*$$scope*/
    ctx[116],
    get_create_row_slot_context
  );
  const create_row_slot_or_fallback = create_row_slot || fallback_block(ctx);
  const block = {
    c: function create() {
      div = element("div");
      button = element("button");
      if (create_row_slot_or_fallback)
        create_row_slot_or_fallback.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button = claim_element(div_nodes, "BUTTON", { type: true, class: true });
      var button_nodes = children(button);
      if (create_row_slot_or_fallback)
        create_row_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "creatable-row svelte-hi60qz");
      toggle_class(
        button,
        "active",
        /*options_filtered*/
        (ctx[24].length ? (
          /*options_filtered*/
          ctx[24].length
        ) : 0) === /*dropdown_index*/
        ctx[20]
      );
      toggle_class(
        button,
        "is-disabled",
        /*createFilter*/
        ctx[1](
          /*input_value*/
          ctx[22]
        )
      );
      add_location(button, file2, 1891, 8, 60729);
      attr_dev(div, "class", "is-dropdown-row svelte-hi60qz");
      add_location(div, file2, 1890, 6, 60691);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button);
      if (create_row_slot_or_fallback) {
        create_row_slot_or_fallback.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(button, "click", prevent_default(
            /*onCreate*/
            ctx[50]
          ), false, true, false, false),
          listen_dev(button, "mousedown", prevent_default(
            /*mousedown_handler_1*/
            ctx[108]
          ), false, true, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (create_row_slot) {
        if (create_row_slot.p && (!current || dirty[0] & /*input_value, i18n_actual*/
        12582912 | dirty[1] & /*isCreating*/
        8 | dirty[3] & /*$$scope*/
        8388608)) {
          update_slot_base(
            create_row_slot,
            create_row_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[116],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[116]
            ) : get_slot_changes(
              create_row_slot_template,
              /*$$scope*/
              ctx2[116],
              dirty,
              get_create_row_slot_changes
            ),
            get_create_row_slot_context
          );
        }
      } else {
        if (create_row_slot_or_fallback && create_row_slot_or_fallback.p && (!current || dirty[0] & /*i18n_actual, input_value*/
        12582912 | dirty[1] & /*meta_key, isCreating*/
        9)) {
          create_row_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[0] & /*options_filtered, dropdown_index*/
      17825792) {
        toggle_class(
          button,
          "active",
          /*options_filtered*/
          (ctx2[24].length ? (
            /*options_filtered*/
            ctx2[24].length
          ) : 0) === /*dropdown_index*/
          ctx2[20]
        );
      }
      if (!current || dirty[0] & /*createFilter, input_value*/
      4194306) {
        toggle_class(
          button,
          "is-disabled",
          /*createFilter*/
          ctx2[1](
            /*input_value*/
            ctx2[22]
          )
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(create_row_slot_or_fallback, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(create_row_slot_or_fallback, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (create_row_slot_or_fallback)
        create_row_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(1890:4) {#if creatable && input_value && !maxReached}",
    ctx
  });
  return block;
}
function fallback_block(ctx) {
  let span0;
  let t0_value = (
    /*i18n_actual*/
    ctx[23].createRowLabel(
      /*input_value*/
      ctx[22]
    ) + ""
  );
  let t0;
  let t1;
  let span1;
  let kbd0;
  let t2;
  let t3;
  let kbd1;
  let textContent = "Enter";
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      kbd0 = element("kbd");
      t2 = text(
        /*meta_key*/
        ctx[31]
      );
      t3 = text("+");
      kbd1 = element("kbd");
      kbd1.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      kbd0 = claim_element(span1_nodes, "KBD", { class: true });
      var kbd0_nodes = children(kbd0);
      t2 = claim_text(
        kbd0_nodes,
        /*meta_key*/
        ctx[31]
      );
      kbd0_nodes.forEach(detach_dev);
      t3 = claim_text(span1_nodes, "+");
      kbd1 = claim_element(span1_nodes, "KBD", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(kbd1) !== "svelte-eby1n8")
        kbd1.textContent = textContent;
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "svelte-hi60qz");
      toggle_class(
        span0,
        "is-loading",
        /*isCreating*/
        ctx[34]
      );
      add_location(span0, file2, 1896, 12, 61106);
      attr_dev(kbd0, "class", "svelte-hi60qz");
      add_location(kbd0, file2, 1897, 35, 61226);
      attr_dev(kbd1, "class", "svelte-hi60qz");
      add_location(kbd1, file2, 1897, 57, 61248);
      attr_dev(span1, "class", "shortcut svelte-hi60qz");
      add_location(span1, file2, 1897, 12, 61203);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      append_hydration_dev(span0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, kbd0);
      append_hydration_dev(kbd0, t2);
      append_hydration_dev(span1, t3);
      append_hydration_dev(span1, kbd1);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*i18n_actual, input_value*/
      12582912 && t0_value !== (t0_value = /*i18n_actual*/
      ctx2[23].createRowLabel(
        /*input_value*/
        ctx2[22]
      ) + ""))
        set_data_dev(t0, t0_value);
      if (dirty[1] & /*isCreating*/
      8) {
        toggle_class(
          span0,
          "is-loading",
          /*isCreating*/
          ctx2[34]
        );
      }
      if (dirty[1] & /*meta_key*/
      1)
        set_data_dev(
          t2,
          /*meta_key*/
          ctx2[31]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span0);
        detach_dev(t1);
        detach_dev(span1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: fallback_block.name,
    type: "fallback",
    source: "(1896:91)              ",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div4;
  let span0;
  let t0;
  let t1;
  let div2;
  let t2;
  let div0;
  let t3;
  let span1;
  let input;
  let input_placeholder_value;
  let input_readonly_value;
  let input_aria_label_value;
  let input_aria_describedby_value;
  let span1_data_value_value;
  let dndzone_action;
  let t4;
  let div1;
  let t5;
  let t6;
  let button;
  let t7;
  let t8;
  let div3;
  let div4_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*is_focused*/
    ctx[27] && create_if_block_14(ctx)
  );
  let if_block1 = (
    /*name*/
    ctx[4] && !/*anchor_element*/
    ctx[6] && create_if_block_13(ctx)
  );
  const icon_slot_template = (
    /*#slots*/
    ctx[107].icon
  );
  const icon_slot = create_slot(
    icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[116],
    get_icon_slot_context
  );
  let if_block2 = (
    /*selectedOptions*/
    ctx[18].length && create_if_block_10(ctx)
  );
  let if_block3 = (
    /*clearable*/
    ctx[9] && !/*disabled*/
    ctx[3] && create_if_block_8(ctx)
  );
  let if_block4 = (
    /*clearable*/
    ctx[9] && create_if_block_7(ctx)
  );
  const dropdown_toggle_slot_template = (
    /*#slots*/
    ctx[107]["dropdown-toggle"]
  );
  const dropdown_toggle_slot = create_slot(
    dropdown_toggle_slot_template,
    ctx,
    /*$$scope*/
    ctx[116],
    get_dropdown_toggle_slot_context
  );
  const dropdown_toggle_slot_or_fallback = dropdown_toggle_slot || fallback_block_3(ctx);
  const control_end_slot_template = (
    /*#slots*/
    ctx[107]["control-end"]
  );
  const control_end_slot = create_slot(
    control_end_slot_template,
    ctx,
    /*$$scope*/
    ctx[116],
    get_control_end_slot_context
  );
  let if_block5 = (
    /*is_mounted*/
    ctx[17] && /*render_dropdown*/
    ctx[30] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div4 = element("div");
      span0 = element("span");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div2 = element("div");
      if (icon_slot)
        icon_slot.c();
      t2 = space();
      div0 = element("div");
      if (if_block2)
        if_block2.c();
      t3 = space();
      span1 = element("span");
      input = element("input");
      t4 = space();
      div1 = element("div");
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      t6 = space();
      button = element("button");
      if (dropdown_toggle_slot_or_fallback)
        dropdown_toggle_slot_or_fallback.c();
      t7 = space();
      if (control_end_slot)
        control_end_slot.c();
      t8 = space();
      div3 = element("div");
      if (if_block5)
        if_block5.c();
      this.h();
    },
    l: function claim(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true, role: true });
      var div4_nodes = children(div4);
      span0 = claim_element(div4_nodes, "SPAN", {
        "aria-live": true,
        "aria-atomic": true,
        "aria-relevant": true,
        class: true
      });
      var span0_nodes = children(span0);
      if (if_block0)
        if_block0.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      t0 = claim_space(div4_nodes);
      if (if_block1)
        if_block1.l(div4_nodes);
      t1 = claim_space(div4_nodes);
      div2 = claim_element(div4_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (icon_slot)
        icon_slot.l(div2_nodes);
      t2 = claim_space(div2_nodes);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block2)
        if_block2.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      span1 = claim_element(div0_nodes, "SPAN", { class: true, "data-value": true });
      var span1_nodes = children(span1);
      input = claim_element(span1_nodes, "INPUT", {
        type: true,
        class: true,
        size: true,
        id: true,
        placeholder: true,
        inputmode: true,
        enterkeyhint: true,
        "aria-label": true,
        "aria-describedby": true,
        autocapitalize: true,
        autocomplete: true,
        autocorrect: true,
        spellcheck: true,
        "aria-autocomplete": true,
        tabindex: true
      });
      span1_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t4 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block3)
        if_block3.l(div1_nodes);
      t5 = claim_space(div1_nodes);
      if (if_block4)
        if_block4.l(div1_nodes);
      t6 = claim_space(div1_nodes);
      button = claim_element(div1_nodes, "BUTTON", {
        type: true,
        class: true,
        "data-action": true,
        tabindex: true
      });
      var button_nodes = children(button);
      if (dropdown_toggle_slot_or_fallback)
        dropdown_toggle_slot_or_fallback.l(button_nodes);
      button_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t7 = claim_space(div2_nodes);
      if (control_end_slot)
        control_end_slot.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      t8 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      if (if_block5)
        if_block5.l(div3_nodes);
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "aria-live", "polite");
      attr_dev(span0, "aria-atomic", "false");
      attr_dev(span0, "aria-relevant", "additions text");
      attr_dev(span0, "class", "a11y-text svelte-hi60qz");
      add_location(span0, file2, 1716, 2, 52200);
      attr_dev(input, "type", "text");
      attr_dev(input, "class", "sv-input--text svelte-hi60qz");
      attr_dev(input, "size", "1");
      attr_dev(
        input,
        "id",
        /*inputId*/
        ctx[2]
      );
      attr_dev(input, "placeholder", input_placeholder_value = /*input_value*/
      ctx[22] ? "" : (
        /*placeholder_active*/
        ctx[46]
      ));
      attr_dev(
        input,
        "inputmode",
        /*input_mode*/
        ctx[47]
      );
      input.readOnly = input_readonly_value = !/*searchable*/
      ctx[8];
      attr_dev(
        input,
        "enterkeyhint",
        /*enter_hint*/
        ctx[42]
      );
      input.disabled = /*disabled*/
      ctx[3];
      attr_dev(input, "aria-label", input_aria_label_value = /*i18n_actual*/
      ctx[23].aria_label);
      attr_dev(input, "aria-describedby", input_aria_describedby_value = /*i18n_actual*/
      ctx[23].aria_describedby);
      attr_dev(input, "autocapitalize", "none");
      attr_dev(input, "autocomplete", "off");
      attr_dev(input, "autocorrect", "off");
      attr_dev(input, "spellcheck", "false");
      attr_dev(input, "aria-autocomplete", "list");
      attr_dev(input, "tabindex", "0");
      toggle_class(input, "keep-value", !/*resetOnBlur*/
      ctx[11]);
      add_location(input, file2, 1772, 8, 55027);
      attr_dev(span1, "class", "sv-input--sizer svelte-hi60qz");
      attr_dev(span1, "data-value", span1_data_value_value = /*input_value*/
      ctx[22] || /*placeholder_active*/
      ctx[46]);
      add_location(span1, file2, 1771, 6, 54941);
      attr_dev(div0, "class", "sv-control--selection svelte-hi60qz");
      toggle_class(
        div0,
        "is-single",
        /*multiple*/
        ctx[0] === false
      );
      toggle_class(
        div0,
        "has-items",
        /*selectedOptions*/
        ctx[18].length > 0
      );
      toggle_class(
        div0,
        "has-input",
        /*input_value*/
        ctx[22].length
      );
      add_location(div0, file2, 1738, 4, 53124);
      attr_dev(button, "type", "button");
      attr_dev(button, "class", "sv-btn-indicator svelte-hi60qz");
      attr_dev(button, "data-action", "toggle");
      attr_dev(button, "tabindex", "-1");
      toggle_class(
        button,
        "sv-dropdown-opened",
        /*is_dropdown_opened*/
        ctx[19]
      );
      add_location(button, file2, 1808, 6, 56874);
      attr_dev(div1, "class", "sv-buttons svelte-hi60qz");
      toggle_class(
        div1,
        "is-loading",
        /*isFetchingData*/
        ctx[33]
      );
      add_location(div1, file2, 1795, 4, 55913);
      attr_dev(div2, "class", "sv-control svelte-hi60qz");
      add_location(div2, file2, 1734, 2, 52977);
      attr_dev(div3, "class", "sv_dropdown svelte-hi60qz");
      toggle_class(
        div3,
        "is-open",
        /*dropdown_show*/
        ctx[29]
      );
      add_location(div3, file2, 1824, 2, 57768);
      attr_dev(div4, "class", div4_class_value = null_to_empty(`svelecte ${/*className*/
      ctx[16]}`) + " svelte-hi60qz");
      attr_dev(div4, "role", "none");
      toggle_class(
        div4,
        "is-required",
        /*required*/
        ctx[5]
      );
      toggle_class(
        div4,
        "is-empty",
        /*selectedOptions*/
        ctx[18].length === 0
      );
      toggle_class(
        div4,
        "is-invalid",
        /*required*/
        ctx[5] && /*selectedOptions*/
        ctx[18].length === 0
      );
      toggle_class(
        div4,
        "is-tainted",
        /*is_tainted*/
        ctx[28]
      );
      toggle_class(
        div4,
        "is-valid",
        /*required*/
        ctx[5] ? (
          /*selectedOptions*/
          ctx[18].length > 0
        ) : true
      );
      toggle_class(
        div4,
        "is-focused",
        /*is_focused*/
        ctx[27]
      );
      toggle_class(
        div4,
        "is-open",
        /*is_dropdown_opened*/
        ctx[19]
      );
      toggle_class(
        div4,
        "is-disabled",
        /*disabled*/
        ctx[3]
      );
      add_location(div4, file2, 1705, 0, 51808);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div4, anchor);
      append_hydration_dev(div4, span0);
      if (if_block0)
        if_block0.m(span0, null);
      append_hydration_dev(div4, t0);
      if (if_block1)
        if_block1.m(div4, null);
      append_hydration_dev(div4, t1);
      append_hydration_dev(div4, div2);
      if (icon_slot) {
        icon_slot.m(div2, null);
      }
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, div0);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration_dev(div0, t3);
      append_hydration_dev(div0, span1);
      append_hydration_dev(span1, input);
      ctx[111](input);
      set_input_value(
        input,
        /*input_value*/
        ctx[22]
      );
      append_hydration_dev(div2, t4);
      append_hydration_dev(div2, div1);
      if (if_block3)
        if_block3.m(div1, null);
      append_hydration_dev(div1, t5);
      if (if_block4)
        if_block4.m(div1, null);
      append_hydration_dev(div1, t6);
      append_hydration_dev(div1, button);
      if (dropdown_toggle_slot_or_fallback) {
        dropdown_toggle_slot_or_fallback.m(button, null);
      }
      append_hydration_dev(div2, t7);
      if (control_end_slot) {
        control_end_slot.m(div2, null);
      }
      append_hydration_dev(div4, t8);
      append_hydration_dev(div4, div3);
      if (if_block5)
        if_block5.m(div3, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "input",
            /*input_input_handler*/
            ctx[112]
          ),
          listen_dev(
            input,
            "focus",
            /*onFocus*/
            ctx[55],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keydown",
            /*onKeyDown*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "keyup",
            /*onKeyUp*/
            ctx[53],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*onInput*/
            ctx[54],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "blur",
            /*onBlur*/
            ctx[56],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "paste",
            /*onPaste*/
            ctx[57],
            false,
            false,
            false,
            false
          ),
          action_destroyer(dndzone_action = /*dndzone*/
          ctx[12].call(null, div0, {
            items: (
              /*selectedOptions*/
              ctx[18]
            ),
            flipDurationMs: (
              /*flipDurationMs*/
              ctx[35]
            ),
            type: (
              /*inputId*/
              ctx[2]
            ),
            dragDisabled: (
              /*doCollapse*/
              ctx[32]
            )
          })),
          listen_dev(
            div0,
            "consider",
            /*onDndEvent*/
            ctx[58],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "finalize",
            /*onDndEvent*/
            ctx[58],
            false,
            false,
            false,
            false
          ),
          listen_dev(div2, "mousedown", onMouseDown, false, false, false, false),
          listen_dev(
            div2,
            "click",
            /*onClick*/
            ctx[51],
            false,
            false,
            false,
            false
          ),
          listen_dev(div3, "mousedown", onMouseDown, false, false, false, false),
          listen_dev(
            div3,
            "click",
            /*onClick*/
            ctx[51],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*is_focused*/
        ctx2[27]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_14(ctx2);
          if_block0.c();
          if_block0.m(span0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*name*/
        ctx2[4] && !/*anchor_element*/
        ctx2[6]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_13(ctx2);
          if_block1.c();
          if_block1.m(div4, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (icon_slot) {
        if (icon_slot.p && (!current || dirty[3] & /*$$scope*/
        8388608)) {
          update_slot_base(
            icon_slot,
            icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[116],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[116]
            ) : get_slot_changes(
              icon_slot_template,
              /*$$scope*/
              ctx2[116],
              dirty,
              get_icon_slot_changes
            ),
            get_icon_slot_context
          );
        }
      }
      if (
        /*selectedOptions*/
        ctx2[18].length
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*selectedOptions*/
          262144) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_10(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*inputId*/
      4) {
        attr_dev(
          input,
          "id",
          /*inputId*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*input_value*/
      4194304 | dirty[1] & /*placeholder_active*/
      32768 && input_placeholder_value !== (input_placeholder_value = /*input_value*/
      ctx2[22] ? "" : (
        /*placeholder_active*/
        ctx2[46]
      ))) {
        attr_dev(input, "placeholder", input_placeholder_value);
      }
      if (!current || dirty[1] & /*input_mode*/
      65536) {
        attr_dev(
          input,
          "inputmode",
          /*input_mode*/
          ctx2[47]
        );
      }
      if (!current || dirty[0] & /*searchable*/
      256 && input_readonly_value !== (input_readonly_value = !/*searchable*/
      ctx2[8])) {
        prop_dev(input, "readOnly", input_readonly_value);
      }
      if (!current || dirty[1] & /*enter_hint*/
      2048) {
        attr_dev(
          input,
          "enterkeyhint",
          /*enter_hint*/
          ctx2[42]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      8) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[3]
        );
      }
      if (!current || dirty[0] & /*i18n_actual*/
      8388608 && input_aria_label_value !== (input_aria_label_value = /*i18n_actual*/
      ctx2[23].aria_label)) {
        attr_dev(input, "aria-label", input_aria_label_value);
      }
      if (!current || dirty[0] & /*i18n_actual*/
      8388608 && input_aria_describedby_value !== (input_aria_describedby_value = /*i18n_actual*/
      ctx2[23].aria_describedby)) {
        attr_dev(input, "aria-describedby", input_aria_describedby_value);
      }
      if (dirty[0] & /*input_value*/
      4194304 && input.value !== /*input_value*/
      ctx2[22]) {
        set_input_value(
          input,
          /*input_value*/
          ctx2[22]
        );
      }
      if (!current || dirty[0] & /*resetOnBlur*/
      2048) {
        toggle_class(input, "keep-value", !/*resetOnBlur*/
        ctx2[11]);
      }
      if (!current || dirty[0] & /*input_value*/
      4194304 | dirty[1] & /*placeholder_active*/
      32768 && span1_data_value_value !== (span1_data_value_value = /*input_value*/
      ctx2[22] || /*placeholder_active*/
      ctx2[46])) {
        attr_dev(span1, "data-value", span1_data_value_value);
      }
      if (dndzone_action && is_function(dndzone_action.update) && dirty[0] & /*selectedOptions, inputId*/
      262148 | dirty[1] & /*flipDurationMs, doCollapse*/
      18)
        dndzone_action.update.call(null, {
          items: (
            /*selectedOptions*/
            ctx2[18]
          ),
          flipDurationMs: (
            /*flipDurationMs*/
            ctx2[35]
          ),
          type: (
            /*inputId*/
            ctx2[2]
          ),
          dragDisabled: (
            /*doCollapse*/
            ctx2[32]
          )
        });
      if (!current || dirty[0] & /*multiple*/
      1) {
        toggle_class(
          div0,
          "is-single",
          /*multiple*/
          ctx2[0] === false
        );
      }
      if (!current || dirty[0] & /*selectedOptions*/
      262144) {
        toggle_class(
          div0,
          "has-items",
          /*selectedOptions*/
          ctx2[18].length > 0
        );
      }
      if (!current || dirty[0] & /*input_value*/
      4194304) {
        toggle_class(
          div0,
          "has-input",
          /*input_value*/
          ctx2[22].length
        );
      }
      if (
        /*clearable*/
        ctx2[9] && !/*disabled*/
        ctx2[3]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*clearable, disabled*/
          520) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_8(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div1, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*clearable*/
        ctx2[9]
      ) {
        if (if_block4) {
        } else {
          if_block4 = create_if_block_7(ctx2);
          if_block4.c();
          if_block4.m(div1, t6);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (dropdown_toggle_slot) {
        if (dropdown_toggle_slot.p && (!current || dirty[0] & /*is_dropdown_opened*/
        524288 | dirty[3] & /*$$scope*/
        8388608)) {
          update_slot_base(
            dropdown_toggle_slot,
            dropdown_toggle_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[116],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[116]
            ) : get_slot_changes(
              dropdown_toggle_slot_template,
              /*$$scope*/
              ctx2[116],
              dirty,
              get_dropdown_toggle_slot_changes
            ),
            get_dropdown_toggle_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*is_dropdown_opened*/
      524288) {
        toggle_class(
          button,
          "sv-dropdown-opened",
          /*is_dropdown_opened*/
          ctx2[19]
        );
      }
      if (!current || dirty[1] & /*isFetchingData*/
      4) {
        toggle_class(
          div1,
          "is-loading",
          /*isFetchingData*/
          ctx2[33]
        );
      }
      if (control_end_slot) {
        if (control_end_slot.p && (!current || dirty[3] & /*$$scope*/
        8388608)) {
          update_slot_base(
            control_end_slot,
            control_end_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[116],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[116]
            ) : get_slot_changes(
              control_end_slot_template,
              /*$$scope*/
              ctx2[116],
              dirty,
              get_control_end_slot_changes
            ),
            get_control_end_slot_context
          );
        }
      }
      if (
        /*is_mounted*/
        ctx2[17] && /*render_dropdown*/
        ctx2[30]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*is_mounted, render_dropdown*/
          1073872896) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div3, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*dropdown_show*/
      536870912) {
        toggle_class(
          div3,
          "is-open",
          /*dropdown_show*/
          ctx2[29]
        );
      }
      if (!current || dirty[0] & /*className*/
      65536 && div4_class_value !== (div4_class_value = null_to_empty(`svelecte ${/*className*/
      ctx2[16]}`) + " svelte-hi60qz")) {
        attr_dev(div4, "class", div4_class_value);
      }
      if (!current || dirty[0] & /*className, required*/
      65568) {
        toggle_class(
          div4,
          "is-required",
          /*required*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*className, selectedOptions*/
      327680) {
        toggle_class(
          div4,
          "is-empty",
          /*selectedOptions*/
          ctx2[18].length === 0
        );
      }
      if (!current || dirty[0] & /*className, required, selectedOptions*/
      327712) {
        toggle_class(
          div4,
          "is-invalid",
          /*required*/
          ctx2[5] && /*selectedOptions*/
          ctx2[18].length === 0
        );
      }
      if (!current || dirty[0] & /*className, is_tainted*/
      268500992) {
        toggle_class(
          div4,
          "is-tainted",
          /*is_tainted*/
          ctx2[28]
        );
      }
      if (!current || dirty[0] & /*className, required, selectedOptions*/
      327712) {
        toggle_class(
          div4,
          "is-valid",
          /*required*/
          ctx2[5] ? (
            /*selectedOptions*/
            ctx2[18].length > 0
          ) : true
        );
      }
      if (!current || dirty[0] & /*className, is_focused*/
      134283264) {
        toggle_class(
          div4,
          "is-focused",
          /*is_focused*/
          ctx2[27]
        );
      }
      if (!current || dirty[0] & /*className, is_dropdown_opened*/
      589824) {
        toggle_class(
          div4,
          "is-open",
          /*is_dropdown_opened*/
          ctx2[19]
        );
      }
      if (!current || dirty[0] & /*className, disabled*/
      65544) {
        toggle_class(
          div4,
          "is-disabled",
          /*disabled*/
          ctx2[3]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(icon_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(dropdown_toggle_slot_or_fallback, local);
      transition_in(control_end_slot, local);
      transition_in(if_block5);
      current = true;
    },
    o: function outro(local) {
      transition_out(icon_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(dropdown_toggle_slot_or_fallback, local);
      transition_out(control_end_slot, local);
      transition_out(if_block5);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div4);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (icon_slot)
        icon_slot.d(detaching);
      if (if_block2)
        if_block2.d();
      ctx[111](null);
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (dropdown_toggle_slot_or_fallback)
        dropdown_toggle_slot_or_fallback.d(detaching);
      if (control_end_slot)
        control_end_slot.d(detaching);
      if (if_block5)
        if_block5.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
settings_default.requestFactory = requestFactory;
var stringFormatters = {
  /**
  * @type {RenderFunction}
  */
  default(item) {
    return escapeHtml(item[this.label]);
  }
};
function addRenderer(name, rendererFn) {
  if (name instanceof Object) {
    for (let prop in name) {
      stringFormatters[prop] = name[prop];
    }
  } else {
    stringFormatters[name] = rendererFn;
  }
}
var config = settings_default;
function onMouseDown(event) {
  event.preventDefault();
}
function instance2($$self, $$props, $$invalidate) {
  let maxReached;
  let options_flat;
  let options_filtered;
  let itemRenderer;
  let vl_listHeight;
  let input_mode;
  let placeholder_active;
  let enter_hint;
  let aria_selection;
  let aria_context;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Svelecte", slots, [
    "icon",
    "collapsedSelection",
    "selection",
    "clear-icon",
    "dropdown-toggle",
    "control-end",
    "list-header",
    "option",
    "create-row"
  ]);
  let { name = "svelecte" } = $$props;
  let { inputId = "" } = $$props;
  let { required = false } = $$props;
  let { disabled = false } = $$props;
  let { anchor_element = null } = $$props;
  let { options = [] } = $$props;
  let { optionResolver = null } = $$props;
  let { valueField = settings_default.valueField } = $$props;
  let { labelField = settings_default.labelField } = $$props;
  let { groupLabelField = settings_default.groupLabelField } = $$props;
  let { groupItemsField = settings_default.groupItemsField } = $$props;
  let { disabledField = settings_default.disabledField } = $$props;
  let { placeholder = settings_default.placeholder } = $$props;
  let { searchable = settings_default.searchable } = $$props;
  let { clearable = settings_default.clearable } = $$props;
  let { renderer = null } = $$props;
  let { disableHighlight = false } = $$props;
  let { highlightFirstItem = settings_default.highlightFirstItem } = $$props;
  let { selectOnTab = settings_default.selectOnTab } = $$props;
  let { resetOnBlur = settings_default.resetOnBlur } = $$props;
  let { resetOnSelect = settings_default.resetOnSelect } = $$props;
  let { closeAfterSelect = settings_default.closeAfterSelect } = $$props;
  let { dndzone = () => ({
    noop: true,
    destroy: () => {
    }
  }) } = $$props;
  let { validatorAction = [] } = $$props;
  let { strictMode = true } = $$props;
  let { multiple = settings_default.multiple } = $$props;
  let { max = settings_default.max } = $$props;
  let { collapseSelection = settings_default.collapseSelection } = $$props;
  let { keepSelectionInList = settings_default.keepSelectionInList } = $$props;
  let { creatable = settings_default.creatable } = $$props;
  let { creatablePrefix = settings_default.creatablePrefix } = $$props;
  let { allowEditing = settings_default.allowEditing } = $$props;
  let { keepCreated = settings_default.keepCreated } = $$props;
  let { delimiter = settings_default.delimiter } = $$props;
  let { createFilter = null } = $$props;
  let { createHandler = null } = $$props;
  let { fetch = null } = $$props;
  let { fetchProps = {} } = $$props;
  let { fetchMode = "auto" } = $$props;
  let { fetchCallback = settings_default.fetchCallback } = $$props;
  let { fetchResetOnBlur = true } = $$props;
  let { fetchDebounceTime = settings_default.fetchDebounceTime } = $$props;
  let { minQuery = settings_default.minQuery } = $$props;
  let { lazyDropdown = settings_default.lazyDropdown } = $$props;
  let { virtualList = settings_default.virtualList } = $$props;
  let { vlHeight = settings_default.vlHeight } = $$props;
  let { vlItemSize = settings_default.vlItemSize } = $$props;
  let { searchProps = null } = $$props;
  let { class: className = "svelecte-control" } = $$props;
  let { i18n = null } = $$props;
  let { readSelection = null } = $$props;
  let { value = null } = $$props;
  let { valueAsObject = settings_default.valueAsObject } = $$props;
  let { parentValue = void 0 } = $$props;
  function focus() {
    ref_input.focus();
  }
  function setSelection(selection, triggerChangeEvent) {
    watch_value_change(selection);
    triggerChangeEvent && emitChangeEvent();
  }
  function getSelection(onlyValues) {
    return onlyValues ? value : readSelection;
  }
  function refetchWith(value2) {
    if (!fetch)
      return;
    fetch_runner({
      init: true,
      initValue: value2,
      storedValue: fetchResetOnBlur
    });
    $$invalidate(63, fetchResetOnBlur = false);
  }
  const dispatch = createEventDispatcher();
  const DOM_ID = `sv-${name}-select`;
  if (fetch && value && valueAsObject && (!options || options && options.length === 0)) {
    options = Array.isArray(value) ? value : [value];
  }
  if (!inputId)
    inputId = `${DOM_ID}-input`;
  multiple = name && !multiple ? name.endsWith("[]") : multiple;
  let is_mounted = false;
  let prev_value;
  let prev_options = optionResolver ? optionResolver(options, /* @__PURE__ */ new Set()) : ensureObjectArray(options, valueField, labelField);
  let prev_parent_value = void 0;
  let currentValueField = valueField || fieldInit("value", prev_options, groupItemsField);
  let currentLabelField = labelField || fieldInit("label", prev_options, groupItemsField);
  let selectedOptions = value !== null ? initSelection(prev_options, value, valueAsObject, groupItemsField, currentValueField) : [];
  const selectedKeys = selectedOptions.reduce(
    (set, opt) => {
      set.add(
        /** @type {object} */
        opt[currentValueField]
      );
      return set;
    },
    /* @__PURE__ */ new Set()
  );
  let alreadyCreated = selectedOptions.filter((opt) => opt.$created);
  let is_focused = false;
  let focus_by_mouse = false;
  let is_tainted = false;
  let is_dropdown_opened = false;
  let dropdown_show = false;
  let dropdown_index = highlightFirstItem ? 0 : null;
  let render_dropdown = !lazyDropdown;
  let dropdown_scroller = null;
  let virtuallist_automode = virtualList && vlHeight === null && vlItemSize === null;
  let vl_height = vlHeight;
  let vl_itemSize = vlItemSize;
  let meta_key;
  let hasEmptyList = false;
  let input_value = "";
  let disable_key_event_bubble = false;
  let i18n_actual;
  let fetch_initOnly = fetchMode === "init" || fetch && fetch.includes("[query]") === false;
  let fetch_initValue = fetch_initOnly ? value : fetch && options.length === 0 ? value : null;
  let isIOS = null;
  let isAndroid = null;
  let doCollapse = collapseSelection !== null;
  let isFetchingData = false;
  let isCreating = false;
  let flipDurationMs = 100;
  let is_dragging = false;
  let is_fetch_dependent = false;
  let ref_input;
  let ref_select_element;
  let ref_container;
  let ref_container_scroll;
  let ref_virtuallist;
  const itemConfig = createConfig(currentValueField, currentLabelField, groupLabelField, groupItemsField);
  watch_i18n(i18n, true);
  function watch_item_props(valueProp, labelProp) {
    if (!is_mounted)
      return;
    if (valueProp) {
      $$invalidate(105, itemConfig.valueField = $$invalidate(26, currentValueField = valueProp), itemConfig);
      selectedKeys.size > 0 && clearSelection();
    }
    if (labelProp) {
      $$invalidate(105, itemConfig.labelField = $$invalidate(102, currentLabelField = labelProp), itemConfig);
      if (renderer === null || renderer === "default") {
        $$invalidate(43, itemRenderer = stringFormatters.default.bind({ label: currentLabelField }));
      }
    }
  }
  function watch_options(opts) {
    if (!is_mounted)
      return;
    if (prev_options !== opts) {
      opts = ensureObjectArray(opts, currentValueField, currentLabelField);
      if (!valueField) {
        const ivalue = fieldInit("value", opts || null, groupItemsField);
        if (!valueField && currentValueField !== ivalue) {
          $$invalidate(105, itemConfig.valueField = $$invalidate(26, currentValueField = ivalue), itemConfig);
          selectedKeys.size > 0 && clearSelection();
        }
      }
      if (!labelField) {
        const ilabel = fieldInit("label", opts || null, groupItemsField);
        if (!labelField && currentLabelField !== ilabel) {
          $$invalidate(105, itemConfig.labelField = ilabel, itemConfig);
          $$invalidate(102, currentLabelField = ilabel);
          if (renderer === null || renderer === "default") {
            $$invalidate(43, itemRenderer = stringFormatters.default.bind({ label: currentLabelField }));
          }
        }
        ;
      }
    }
    $$invalidate(60, options = opts);
    $$invalidate(101, prev_options = optionResolver ? optionResolver(opts, selectedKeys) : opts);
  }
  function watch_value_change(passedVal, opts) {
    if (prev_value === passedVal && !(opts == null ? void 0 : opts.skipEqualityCheck))
      return;
    clearSelection();
    if (passedVal) {
      if (multiple && !Array.isArray(passedVal) || !multiple && Array.isArray(passedVal)) {
        console.warn(`Passed 'value' property should ${multiple ? "be" : "NOT be"} an array`);
      }
      if (fetch_initValue)
        return;
      const arrValue = Array.isArray(passedVal) ? passedVal : [passedVal];
      const _selection = arrValue.reduce(
        (res, val) => {
          if (valueAsObject && (!strictMode || creatable && val.$created)) {
            res.push(val);
            return res;
          }
          const opt = options_flat.find((item) => item[currentValueField] == val);
          if (opt) {
            res.push(opt);
          } else {
            !strictMode && res.push(
              // only sync (or default) handler is allowed for code simplicty
              createHandler ? createHandler({
                inputValue: val,
                valueField: currentValueField,
                labelField: currentLabelField,
                prefix: creatablePrefix
              }) : {
                [currentValueField]: val,
                [currentLabelField]: val
              }
            );
          }
          return res;
        },
        []
      );
      let success = _selection.every(selectOption) && (multiple ? arrValue.length === _selection.length : _selection.length > 0);
      if (!success) {
        console.warn('[Svelecte]: provided "value" property is invalid', passedVal);
        $$invalidate(62, value = multiple ? [] : null);
        $$invalidate(64, readSelection = value);
        dispatch("invalidValue", passedVal);
        return;
      }
      $$invalidate(64, readSelection = Array.isArray(passedVal) ? _selection : _selection.shift());
    }
    prev_value = passedVal;
  }
  function watch_selectedOptions(newSelection) {
    if (is_dragging)
      return;
    const selection_formatted = newSelection.map((opt) => {
      const { "$disabled": unused1, "$isGroupItem": unused2, ...obj } = opt;
      return obj;
    });
    const unified_selection = multiple ? selection_formatted : selection_formatted.length ? selection_formatted[0] : null;
    if (!valueAsObject) {
      prev_value = multiple ? unified_selection.map((opt) => opt[currentValueField]) : selectedOptions.length ? unified_selection[currentValueField] : null;
    } else {
      prev_value = unified_selection;
    }
    $$invalidate(62, value = prev_value);
    $$invalidate(64, readSelection = unified_selection);
    if (max && newSelection.length === max) {
      $$invalidate(41, listMessage = i18n_actual.max(max));
    }
  }
  function watch_parentValue(newParentValue) {
    if (newParentValue !== void 0 && prev_parent_value !== newParentValue || newParentValue === void 0 && prev_parent_value !== newParentValue) {
      const disabled_to_set = newParentValue === void 0 ? false : !newParentValue ? true : false;
      clearSelection();
      prev_value = multiple ? [] : null;
      $$invalidate(3, disabled = disabled_to_set);
    }
    prev_parent_value = newParentValue;
    is_fetch_dependent = newParentValue !== void 0;
  }
  function watch_options_virtualList(_watchTrigger) {
    if (!is_mounted || !render_dropdown)
      return;
    tick().then(() => {
      if (!ref_virtuallist)
        return;
      const dimensions = virtualListDimensionsResolver(ref_virtuallist, ref_container_scroll, options_filtered);
      $$invalidate(21, vl_itemSize = dimensions.size);
      $$invalidate(104, vl_height = dimensions.height);
    }).then(() => positionDropdown(is_dropdown_opened, ref_container_scroll, render_dropdown));
  }
  function watch_is_dropdown_opened(val) {
    if (!is_mounted)
      return;
    if (val && !focus_by_mouse)
      focus_by_mouse = true;
    if (!render_dropdown && val)
      $$invalidate(30, render_dropdown = true);
    tick().then(() => {
      virtuallist_automode && watch_options_virtualList();
    }).then(() => {
      positionDropdown(val, ref_container_scroll, true);
      if (val) {
        if (highlightFirstItem && (selectedOptions.length === 0 || multiple))
          setDropdownIndex(0, { asc: true });
        if (!multiple && selectedOptions.length) {
          $$invalidate(20, dropdown_index = options_flat.findIndex((opt) => opt === selectedOptions[0]));
        }
        scrollIntoView(
          {
            container: ref_container,
            scrollContainer: ref_container_scroll,
            virtualList,
            center: false
          },
          dropdown_index
        );
      }
      tick().then(() => $$invalidate(29, dropdown_show = val));
    });
    if (!dropdown_scroller)
      dropdown_scroller = () => positionDropdown(val, ref_container_scroll, true);
    document[val ? "addEventListener" : "removeEventListener"]("scroll", dropdown_scroller, { passive: true });
  }
  function watch_i18n(obj, forceInit = null) {
    if (is_mounted || forceInit) {
      $$invalidate(23, i18n_actual = Object.assign({}, config.i18n, obj || {}));
    }
  }
  function watch_listMessage(maxReached2, options_filtered2) {
    if (fetch && !fetch_initOnly)
      return;
    if (maxReached2) {
      $$invalidate(41, listMessage = i18n_actual.max(max));
      return;
    }
    $$invalidate(41, listMessage = options_filtered2.length !== options_flat.length ? creatable ? i18n_actual.emptyCreatable : i18n_actual.nomatch : creatable ? i18n_actual.emptyCreatable : i18n_actual.empty);
  }
  function emitChangeEvent() {
    tick().then(() => {
      dispatch("change", readSelection);
      if (ref_select_element) {
        ref_select_element.dispatchEvent(new Event("input"));
        ref_select_element.dispatchEvent(new Event("change"));
      }
    });
  }
  function emitCreateEvent(createdOpt) {
    dispatch("createoption", createdOpt);
  }
  function onSelect(event, opt) {
    opt = opt || event.detail;
    if (disabled || opt[disabledField] || opt.$isGroupHeader)
      return;
    if (!opt || multiple && maxReached)
      return false;
    if (selectedKeys.has(opt[currentValueField]))
      return onDeselect(null, opt);
    if (typeof opt === "string") {
      if (!creatable)
        return;
      opt = onCreate_helper(opt);
      if (alreadyCreated.includes(opt) || selectedKeys.has(opt))
        return;
      $$invalidate(34, isCreating = true);
      Promise.resolve(createHandler.call(null, {
        inputValue: opt,
        valueField: currentValueField,
        labelField: currentLabelField,
        prefix: creatablePrefix
      })).then((newObj) => {
        $$invalidate(34, isCreating = false);
        !fetch && alreadyCreated.push(opt);
        newObj.$created = true;
        if (keepCreated)
          $$invalidate(101, prev_options = [...prev_options, newObj]);
        emitCreateEvent(newObj);
        selectOption(newObj);
        onSelectTeardown();
        emitChangeEvent();
      }).catch((e) => {
        dispatch("createFail", { input: opt, error: e });
      });
      return;
    }
    selectOption(opt);
    onSelectTeardown();
    emitChangeEvent();
  }
  function onSelectTeardown() {
    if (multiple && resetOnSelect || !multiple)
      $$invalidate(22, input_value = "");
    if (closeAfterSelect === true || closeAfterSelect === "auto" && !multiple) {
      $$invalidate(19, is_dropdown_opened = false);
    }
    if (max && selectedOptions.length == max) {
      $$invalidate(20, dropdown_index = 0);
    }
  }
  function selectOption(opt) {
    opt.$selected = true;
    if (multiple) {
      selectedOptions.push(opt);
      $$invalidate(18, selectedOptions);
      selectedKeys.add(opt[currentValueField]);
    } else {
      const previousSelected = selectedOptions.shift();
      if (previousSelected)
        previousSelected.$selected = false;
      $$invalidate(18, selectedOptions = [opt]);
      selectedKeys.clear();
      selectedKeys.add(opt[currentValueField]);
      tick().then(() => {
        $$invalidate(20, dropdown_index = options_flat.indexOf(opt));
      });
    }
    if (optionResolver) {
      $$invalidate(101, prev_options = optionResolver(options, selectedKeys));
      return true;
    }
    $$invalidate(106, options_flat), $$invalidate(101, prev_options), $$invalidate(105, itemConfig);
    return true;
  }
  function onDeselect(event = {}, opt = null, backspacePressed) {
    if (disabled)
      return;
    opt = opt || event.detail;
    if (opt) {
      deselectOption(opt, backspacePressed);
      keepSelectionInList !== true && tick().then(() => scrollIntoView(
        {
          scrollContainer: ref_container_scroll,
          container: ref_container,
          virtualList,
          center: false
        },
        dropdown_index
      ));
    } else {
      clearSelection();
    }
    emitChangeEvent();
  }
  function deselectOption(opt, backspacePressed) {
    if (opt.$created) {
      alreadyCreated.splice(alreadyCreated.findIndex((o) => o === opt[currentValueField]), 1);
      $$invalidate(103, alreadyCreated);
      if (keepCreated) {
        const idx = prev_options.findIndex((o) => o[currentValueField] === opt[currentValueField]);
        idx !== -1 && prev_options.splice(idx, 1);
        $$invalidate(101, prev_options);
      }
      if (backspacePressed && allowEditing) {
        $$invalidate(22, input_value = opt[currentLabelField].replace(creatablePrefix, ""));
      }
    }
    opt.$selected = false;
    const id = opt[currentValueField];
    selectedKeys.delete(id);
    selectedOptions.splice(selectedOptions.findIndex((o) => o[currentValueField] == id), 1);
    $$invalidate(18, selectedOptions);
    if (optionResolver) {
      $$invalidate(101, prev_options = optionResolver(options, selectedKeys));
      return;
    }
    $$invalidate(106, options_flat = fetch && !fetch_initOnly && fetchResetOnBlur ? [] : options_flat);
  }
  function clearSelection() {
    if (selectedKeys.size === 0)
      return;
    selectedKeys.clear();
    $$invalidate(18, selectedOptions = selectedOptions.reduce(
      (_, opt) => {
        opt.$selected = false;
        return [];
      },
      []
    ));
    if (!keepCreated)
      $$invalidate(103, alreadyCreated = []);
    $$invalidate(25, maxReached = false);
    if (input_value)
      $$invalidate(22, input_value = "");
    if (optionResolver) {
      $$invalidate(101, prev_options = optionResolver(options, selectedKeys));
      return;
    }
    $$invalidate(106, options_flat = fetch && !fetch_initOnly && fetchResetOnBlur ? [] : options_flat);
  }
  function onCreate(_event) {
    if (alreadyCreated.includes(input_value))
      return;
    onSelect(null, input_value);
  }
  function processKeyDown(event) {
    if (creatable && delimiter.indexOf(event.key) > -1) {
      input_value.length > 0 && onSelect(null, input_value);
      event.preventDefault();
      return;
    }
    const Tab = selectOnTab && is_dropdown_opened && !event.shiftKey ? "Tab" : "No-tab";
    let ctrlKey = isIOS ? event.metaKey : event.ctrlKey;
    let isPageEvent = ["PageUp", "PageDown"].includes(event.key);
    let backspacePressed = false;
    let supressIndexMove = false;
    switch (event.key) {
      case "End":
        if (input_value.length !== 0)
          return;
        setDropdownIndex(options_filtered.length, { desc: true });
      case "PageDown":
        if (isPageEvent) {
          const [wrap, item] = get_dropdown_dimensions();
          $$invalidate(20, dropdown_index = Math.min(
            Math.ceil((item * dropdown_index + wrap) / item),
            // can be more than max, therefore Math.min
            options_filtered.length
          ));
        }
      case "ArrowUp":
        event.preventDefault();
        if (!is_dropdown_opened) {
          $$invalidate(19, is_dropdown_opened = true);
          return;
        }
        setDropdownIndex(dropdown_index - 1, { desc: true });
        tick().then(() => scrollIntoView(
          {
            scrollContainer: ref_container_scroll,
            container: ref_container,
            virtualList,
            center: false
          },
          dropdown_index
        ));
        break;
      case "Home":
        supressIndexMove = true;
        if (input_value.length !== 0 || input_value.length === 0 && options_filtered.length === 0)
          return;
        setDropdownIndex(
          0,
          { asc: true }
        );
      case "PageUp":
        if (isPageEvent) {
          const [wrap, item] = get_dropdown_dimensions();
          $$invalidate(20, dropdown_index = Math.floor((item * dropdown_index - wrap) / item));
        }
      case "ArrowDown":
        event.preventDefault();
        if (!is_dropdown_opened) {
          $$invalidate(19, is_dropdown_opened = true);
          return;
        }
        const dix = dropdown_index === null ? -1 : dropdown_index;
        !supressIndexMove && setDropdownIndex(dix + 1, { asc: true });
        tick().then(() => scrollIntoView(
          {
            scrollContainer: ref_container_scroll,
            container: ref_container,
            virtualList,
            center: false
          },
          dropdown_index
        ));
        break;
      case "Escape":
        if (is_dropdown_opened) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (!input_value) {
          $$invalidate(19, is_dropdown_opened = false);
        }
        $$invalidate(22, input_value = "");
        break;
      case Tab:
      case "Enter":
        if (!is_dropdown_opened) {
          event.key !== Tab && dispatch("enterKey", event);
          return;
        }
        let activeDropdownItem = !ctrlKey ? options_filtered[dropdown_index] : null;
        if (creatable && input_value) {
          activeDropdownItem = !activeDropdownItem || ctrlKey ? onCreate_helper(input_value) : activeDropdownItem;
          ctrlKey = false;
        }
        !ctrlKey && activeDropdownItem && onSelect(null, activeDropdownItem);
        if (options_filtered.length <= dropdown_index) {
          setDropdownIndex(options_filtered.length - 1);
        }
        if (!activeDropdownItem && selectedOptions.length) {
          $$invalidate(19, is_dropdown_opened = false);
          event.key !== Tab && dispatch("enterKey", event);
          return;
        }
        (event.key !== Tab || event.key === Tab && selectOnTab !== "select-navigate") && event.preventDefault();
        break;
      case " ":
        if (!fetch && !is_dropdown_opened) {
          $$invalidate(
            19,
            is_dropdown_opened = true
          );
          event.preventDefault();
        }
        break;
      case "Backspace":
        if (collapseSelection === "always")
          return;
        backspacePressed = true;
      case "Delete":
        if (input_value === "" && selectedOptions.length) {
          ctrlKey ? onDeselect({}) : onDeselect(
            /** no detail prop */
            null,
            selectedOptions[selectedOptions.length - 1],
            backspacePressed
          );
          event.preventDefault();
        }
      default:
        if (!ctrlKey && !["Tab", "Shift"].includes(event.key) && !is_dropdown_opened && !isFetchingData) {
          $$invalidate(19, is_dropdown_opened = true);
        }
    }
  }
  function onClick(event) {
    if (disabled)
      return;
    const target = event.target.closest("[data-action]");
    if (!focus_by_mouse)
      focus_by_mouse = true;
    if ((target == null ? void 0 : target.dataset.action) === "default")
      return;
    event.preventDefault();
    const dropdown_item = event.target.closest("[data-pos]");
    if (!target && !dropdown_item) {
      return focusControl(event.target);
    }
    const action = (target == null ? void 0 : target.dataset.action) || "select";
    switch (action) {
      case "deselect":
        let bound_item = target.bound_item;
        if (!bound_item) {
          const dataId = target.dataset.id;
          bound_item = selectedOptions.filter((o) => o[currentValueField] == dataId).shift();
        }
        onDeselect({}, bound_item);
        bound_item && !is_focused && ref_input.focus();
        break;
      case "select":
        const opt_position = parseInt(dropdown_item.dataset.pos);
        onSelect(null, options_filtered[opt_position]);
        break;
      case "toggle":
        $$invalidate(19, is_dropdown_opened = !is_dropdown_opened);
        break;
    }
  }
  function onKeyDown(e) {
    if (android() && !enter_hint && e.key === "Enter")
      return true;
    disable_key_event_bubble = ["Enter", "Escape"].includes(e.key) && is_dropdown_opened;
    processKeyDown(e);
  }
  function onKeyUp(e) {
    if (disable_key_event_bubble) {
      e.stopImmediatePropagation();
      e.preventDefault();
    }
    disable_key_event_bubble = false;
  }
  function onInput() {
    if (selectedOptions.length === 1 && !multiple) {
    }
  }
  function onFocus() {
    $$invalidate(27, is_focused = true);
    $$invalidate(19, is_dropdown_opened = focus_by_mouse);
    if (!is_tainted)
      $$invalidate(28, is_tainted = true);
    collapseSelection === "blur" && !is_dragging && setTimeout(
      () => {
        $$invalidate(32, doCollapse = false);
      },
      100
    );
    dispatch("focus", ref_input);
  }
  function onBlur() {
    $$invalidate(27, is_focused = false);
    $$invalidate(19, is_dropdown_opened = false);
    focus_by_mouse = false;
    if (resetOnBlur) {
      $$invalidate(22, input_value = "");
    } else {
      fetch_controller && !fetch_initOnly && fetch_controller.abort("blur");
    }
    collapseSelection === "blur" && !is_dragging && setTimeout(
      () => {
        $$invalidate(32, doCollapse = true);
      },
      100
    );
    dispatch("blur", ref_input);
  }
  function onPaste(event) {
    if (creatable) {
      event.preventDefault();
      const rx = new RegExp("([^" + delimiter + "\\n]+)", "g");
      const pasted = event.clipboardData.getData("text/plain").replace(/\//g, "/").replace(/\t/g, " ");
      const matches = pasted.match(rx);
      if (matches.length === 1 && pasted.indexOf(",") === -1) {
        $$invalidate(22, input_value = matches.pop().trim());
      }
      matches.forEach((opt) => onSelect(null, opt.trim()));
    }
  }
  function onDndEvent(e) {
    is_dragging = e.type === "consider";
    $$invalidate(18, selectedOptions = e.detail.items);
    if (!is_dragging) {
      emitChangeEvent();
      if (collapseSelection === "blur")
        setTimeout(
          () => {
            $$invalidate(32, doCollapse = true);
          },
          200
        );
    }
  }
  let fetch_controller;
  let debouncedFetch;
  let listMessage = fetch ? fetch_initOnly ? i18n_actual.fetchInit : minQuery > 1 ? i18n_actual.fetchQuery(minQuery, 0) : i18n_actual.fetchBefore : creatable ? i18n_actual.emptyCreatable : i18n_actual.empty;
  function watch_fetch_init(fetch2, _parentValue) {
    if (!fetch2) {
      debouncedFetch = null;
      return;
    }
    if (fetch_initOnly || fetch_initValue) {
      $$invalidate(33, isFetchingData = true);
      fetch_runner({ init: true });
    }
    debouncedFetch = debounce(fetch_runner, fetchDebounceTime);
  }
  let fetch_store = writable({ control: null });
  const fetch_reset = (control = null) => fetch_store.update((val) => {
    var _a;
    (_a = val.control) == null ? void 0 : _a.abort();
    return { control };
  });
  function trigger_fetch(inputValue) {
    if (fetch_initOnly || maxReached)
      return;
    if (debouncedFetch) {
      fetch_reset();
      $$invalidate(33, isFetchingData = true);
      if (input_value.length < minQuery) {
        $$invalidate(33, isFetchingData = false);
      }
      if (fetchResetOnBlur)
        $$invalidate(24, options_filtered = []);
      $$invalidate(29, dropdown_show = inputValue.length >= minQuery ? false : true);
      $$invalidate(41, listMessage = minQuery <= 1 ? i18n_actual.fetchBefore : i18n_actual.fetchQuery(minQuery, inputValue.length));
      debouncedFetch();
    }
  }
  function fetch_runner(opts = {}) {
    fetch_reset();
    if (opts.init !== true && !input_value.length || is_fetch_dependent && !parentValue) {
      $$invalidate(33, isFetchingData = false);
      if (fetchResetOnBlur) {
        $$invalidate(101, prev_options = optionResolver ? optionResolver(options, selectedKeys) : []);
      }
      return;
    }
    if (input_value && input_value.length < minQuery) {
      $$invalidate(33, isFetchingData = false);
      return;
    }
    if (fetch_initOnly && prev_value && (!multiple || (prev_value == null ? void 0 : prev_value.length) > 0))
      fetch_initValue = prev_value;
    const initial = fetch_initValue || opts.initValue;
    if (fetch_initOnly)
      $$invalidate(41, listMessage = i18n_actual.fetchInit);
    const built = settings_default.requestFactory(input_value, { parentValue, url: fetch, initial }, fetchProps);
    fetch_controller = built.controller;
    fetch_reset(built.controller);
    window.fetch(built.request).then((resp) => resp.json()).then(
      /** @type {object} */
      (json) => {
        if (!Array.isArray(json) && (json == null ? void 0 : json.error))
          dispatch("fetchError", json.error);
        return Promise.resolve(fetchCallback ? fetchCallback(json) : json.data || json.items || json.options || json).then((data) => {
          if (!Array.isArray(data)) {
            console.warn("[Svelecte]:Fetch - array expected, invalid property provided:", data);
            data = [];
          }
          $$invalidate(101, prev_options = data);
          dispatch("fetch", data);
          tick().then(() => {
            if (initial) {
              fetch_initValue = null;
              watch_value_change(initial, { skipEqualityCheck: true });
              if ("storedValue" in opts)
                $$invalidate(63, fetchResetOnBlur = opts.storedValue);
            }
          });
        });
      }
    ).catch((e) => {
      if (e instanceof DOMException && e.name === "AbortError")
        return true;
      $$invalidate(101, prev_options = []);
      dispatch("fetchError", e);
      console.warn("[Svelecte] Fetch Error:", e);
    }).then((fetchAborted) => {
      if (fetchAborted === true)
        return;
      $$invalidate(41, listMessage = fetch_initOnly ? i18n_actual.empty : initial ? minQuery > 1 ? i18n_actual.fetchQuery(minQuery, 0) : i18n_actual.fetchBefore : i18n_actual.fetchEmpty);
      fetch_controller = null;
      $$invalidate(33, isFetchingData = false);
      if (is_focused)
        $$invalidate(19, is_dropdown_opened = true);
      if (is_dropdown_opened && !dropdown_show) {
        $$invalidate(29, dropdown_show = true);
      }
    });
  }
  function resolveExcludedValue(inputValue) {
    if (!keepSelectionInList)
      return selectedKeys;
    if (keepSelectionInList === true)
      return inputValue ? selectedKeys : null;
    return inputValue ? selectedKeys : multiple ? selectedKeys : null;
  }
  function setDropdownIndex(pos, direction = {}, limit = 0) {
    var _a;
    const dropdown_list_length = creatable ? options_filtered.length + 1 : options_filtered.length;
    if (limit >= 2)
      return;
    if (pos < 0)
      pos = direction.desc ? dropdown_list_length - 1 : 0;
    if (dropdown_index === null && highlightFirstItem || pos >= dropdown_list_length) {
      pos = 0;
    }
    if ((_a = options_filtered[pos]) == null ? void 0 : _a.$isGroupHeader) {
      setDropdownIndex(direction.asc ? pos + 1 : pos - 1, direction, ++limit);
      return;
    }
    $$invalidate(20, dropdown_index = pos);
  }
  function focusControl(target) {
    if (disabled)
      return;
    if (!is_focused) {
      ref_input.focus();
      return;
    }
    if (target.tagName === "INPUT" && input_value) {
      return;
    }
    $$invalidate(19, is_dropdown_opened = !is_dropdown_opened);
  }
  function get_dropdown_dimensions() {
    if (virtualList) {
      return [ref_container_scroll.offsetHeight, vl_itemSize];
    }
    return [
      ref_container_scroll.offsetHeight,
      // @ts-ignore
      ref_container.firstElementChild.offsetHeight
    ];
  }
  const svelte_use_form_validator = validatorAction.length ? validatorAction.shift() : () => {
  };
  onMount(() => {
    $$invalidate(17, is_mounted = true);
    isAndroid = android();
    isIOS = iOS();
    $$invalidate(31, meta_key = isIOS ? "âŒ˜" : "Ctrl");
    if (anchor_element) {
      $$invalidate(37, ref_select_element = document.getElementById(anchor_element));
      $$invalidate(37, ref_select_element.className = "sv-hidden-element", ref_select_element);
      $$invalidate(37, ref_select_element.innerHTML = "", ref_select_element);
      $$invalidate(37, ref_select_element.tabIndex = -1, ref_select_element);
      selectedKeys.forEach((k) => {
        ref_select_element.insertAdjacentHTML("beforeend", `<option value=${k} selected>${k}</option>`);
      });
    } else if (selectedOptions.length) {
      setTimeout(
        () => {
          Array.from(ref_select_element.children).forEach(
            /** @type {HTMLOptionElement} */
            (opt) => {
              opt.selected = true;
            }
          );
        },
        200
      );
    }
    ;
    if (window.matchMedia("(prefers-reduced-motion: reduce)").matches)
      $$invalidate(35, flipDurationMs = 0);
  });
  const writable_props = [
    "name",
    "inputId",
    "required",
    "disabled",
    "anchor_element",
    "options",
    "optionResolver",
    "valueField",
    "labelField",
    "groupLabelField",
    "groupItemsField",
    "disabledField",
    "placeholder",
    "searchable",
    "clearable",
    "renderer",
    "disableHighlight",
    "highlightFirstItem",
    "selectOnTab",
    "resetOnBlur",
    "resetOnSelect",
    "closeAfterSelect",
    "dndzone",
    "validatorAction",
    "strictMode",
    "multiple",
    "max",
    "collapseSelection",
    "keepSelectionInList",
    "creatable",
    "creatablePrefix",
    "allowEditing",
    "keepCreated",
    "delimiter",
    "createFilter",
    "createHandler",
    "fetch",
    "fetchProps",
    "fetchMode",
    "fetchCallback",
    "fetchResetOnBlur",
    "fetchDebounceTime",
    "minQuery",
    "lazyDropdown",
    "virtualList",
    "vlHeight",
    "vlItemSize",
    "searchProps",
    "class",
    "i18n",
    "readSelection",
    "value",
    "valueAsObject",
    "parentValue"
  ];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<Svelecte> was created with unknown prop '${key}'`);
  });
  function mousedown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function select_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref_select_element = $$value;
      $$invalidate(37, ref_select_element);
      $$invalidate(18, selectedOptions);
      $$invalidate(26, currentValueField);
    });
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref_input = $$value;
      $$invalidate(36, ref_input);
    });
  }
  function input_input_handler() {
    input_value = this.value;
    $$invalidate(22, input_value);
  }
  function tinyvirtuallist_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref_virtuallist = $$value;
      $$invalidate(40, ref_virtuallist);
    });
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref_container = $$value;
      $$invalidate(38, ref_container);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      ref_container_scroll = $$value;
      $$invalidate(39, ref_container_scroll);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("inputId" in $$props2)
      $$invalidate(2, inputId = $$props2.inputId);
    if ("required" in $$props2)
      $$invalidate(5, required = $$props2.required);
    if ("disabled" in $$props2)
      $$invalidate(3, disabled = $$props2.disabled);
    if ("anchor_element" in $$props2)
      $$invalidate(6, anchor_element = $$props2.anchor_element);
    if ("options" in $$props2)
      $$invalidate(60, options = $$props2.options);
    if ("optionResolver" in $$props2)
      $$invalidate(65, optionResolver = $$props2.optionResolver);
    if ("valueField" in $$props2)
      $$invalidate(66, valueField = $$props2.valueField);
    if ("labelField" in $$props2)
      $$invalidate(67, labelField = $$props2.labelField);
    if ("groupLabelField" in $$props2)
      $$invalidate(68, groupLabelField = $$props2.groupLabelField);
    if ("groupItemsField" in $$props2)
      $$invalidate(69, groupItemsField = $$props2.groupItemsField);
    if ("disabledField" in $$props2)
      $$invalidate(7, disabledField = $$props2.disabledField);
    if ("placeholder" in $$props2)
      $$invalidate(70, placeholder = $$props2.placeholder);
    if ("searchable" in $$props2)
      $$invalidate(8, searchable = $$props2.searchable);
    if ("clearable" in $$props2)
      $$invalidate(9, clearable = $$props2.clearable);
    if ("renderer" in $$props2)
      $$invalidate(71, renderer = $$props2.renderer);
    if ("disableHighlight" in $$props2)
      $$invalidate(10, disableHighlight = $$props2.disableHighlight);
    if ("highlightFirstItem" in $$props2)
      $$invalidate(72, highlightFirstItem = $$props2.highlightFirstItem);
    if ("selectOnTab" in $$props2)
      $$invalidate(73, selectOnTab = $$props2.selectOnTab);
    if ("resetOnBlur" in $$props2)
      $$invalidate(11, resetOnBlur = $$props2.resetOnBlur);
    if ("resetOnSelect" in $$props2)
      $$invalidate(74, resetOnSelect = $$props2.resetOnSelect);
    if ("closeAfterSelect" in $$props2)
      $$invalidate(75, closeAfterSelect = $$props2.closeAfterSelect);
    if ("dndzone" in $$props2)
      $$invalidate(12, dndzone = $$props2.dndzone);
    if ("validatorAction" in $$props2)
      $$invalidate(13, validatorAction = $$props2.validatorAction);
    if ("strictMode" in $$props2)
      $$invalidate(76, strictMode = $$props2.strictMode);
    if ("multiple" in $$props2)
      $$invalidate(0, multiple = $$props2.multiple);
    if ("max" in $$props2)
      $$invalidate(77, max = $$props2.max);
    if ("collapseSelection" in $$props2)
      $$invalidate(78, collapseSelection = $$props2.collapseSelection);
    if ("keepSelectionInList" in $$props2)
      $$invalidate(79, keepSelectionInList = $$props2.keepSelectionInList);
    if ("creatable" in $$props2)
      $$invalidate(14, creatable = $$props2.creatable);
    if ("creatablePrefix" in $$props2)
      $$invalidate(80, creatablePrefix = $$props2.creatablePrefix);
    if ("allowEditing" in $$props2)
      $$invalidate(81, allowEditing = $$props2.allowEditing);
    if ("keepCreated" in $$props2)
      $$invalidate(82, keepCreated = $$props2.keepCreated);
    if ("delimiter" in $$props2)
      $$invalidate(83, delimiter = $$props2.delimiter);
    if ("createFilter" in $$props2)
      $$invalidate(1, createFilter = $$props2.createFilter);
    if ("createHandler" in $$props2)
      $$invalidate(61, createHandler = $$props2.createHandler);
    if ("fetch" in $$props2)
      $$invalidate(84, fetch = $$props2.fetch);
    if ("fetchProps" in $$props2)
      $$invalidate(85, fetchProps = $$props2.fetchProps);
    if ("fetchMode" in $$props2)
      $$invalidate(86, fetchMode = $$props2.fetchMode);
    if ("fetchCallback" in $$props2)
      $$invalidate(87, fetchCallback = $$props2.fetchCallback);
    if ("fetchResetOnBlur" in $$props2)
      $$invalidate(63, fetchResetOnBlur = $$props2.fetchResetOnBlur);
    if ("fetchDebounceTime" in $$props2)
      $$invalidate(88, fetchDebounceTime = $$props2.fetchDebounceTime);
    if ("minQuery" in $$props2)
      $$invalidate(89, minQuery = $$props2.minQuery);
    if ("lazyDropdown" in $$props2)
      $$invalidate(90, lazyDropdown = $$props2.lazyDropdown);
    if ("virtualList" in $$props2)
      $$invalidate(15, virtualList = $$props2.virtualList);
    if ("vlHeight" in $$props2)
      $$invalidate(91, vlHeight = $$props2.vlHeight);
    if ("vlItemSize" in $$props2)
      $$invalidate(92, vlItemSize = $$props2.vlItemSize);
    if ("searchProps" in $$props2)
      $$invalidate(93, searchProps = $$props2.searchProps);
    if ("class" in $$props2)
      $$invalidate(16, className = $$props2.class);
    if ("i18n" in $$props2)
      $$invalidate(94, i18n = $$props2.i18n);
    if ("readSelection" in $$props2)
      $$invalidate(64, readSelection = $$props2.readSelection);
    if ("value" in $$props2)
      $$invalidate(62, value = $$props2.value);
    if ("valueAsObject" in $$props2)
      $$invalidate(95, valueAsObject = $$props2.valueAsObject);
    if ("parentValue" in $$props2)
      $$invalidate(96, parentValue = $$props2.parentValue);
    if ("$$scope" in $$props2)
      $$invalidate(116, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    defaults: settings_default,
    requestFactory,
    debounce,
    onCreate_helper,
    escapeHtml,
    stringFormatters,
    addRenderer,
    config,
    createEventDispatcher,
    onMount,
    tick,
    writable,
    flip,
    TinyVirtualList: VirtualList_default,
    positionDropdown,
    scrollIntoView,
    virtualListDimensionsResolver,
    createConfig,
    ensureObjectArray,
    filterList,
    flatList,
    getFilterProps,
    initSelection,
    fieldInit,
    iOS,
    android,
    highlightSearch,
    bindItem,
    name,
    inputId,
    required,
    disabled,
    anchor_element,
    options,
    optionResolver,
    valueField,
    labelField,
    groupLabelField,
    groupItemsField,
    disabledField,
    placeholder,
    searchable,
    clearable,
    renderer,
    disableHighlight,
    highlightFirstItem,
    selectOnTab,
    resetOnBlur,
    resetOnSelect,
    closeAfterSelect,
    dndzone,
    validatorAction,
    strictMode,
    multiple,
    max,
    collapseSelection,
    keepSelectionInList,
    creatable,
    creatablePrefix,
    allowEditing,
    keepCreated,
    delimiter,
    createFilter,
    createHandler,
    fetch,
    fetchProps,
    fetchMode,
    fetchCallback,
    fetchResetOnBlur,
    fetchDebounceTime,
    minQuery,
    lazyDropdown,
    virtualList,
    vlHeight,
    vlItemSize,
    searchProps,
    className,
    i18n,
    readSelection,
    value,
    valueAsObject,
    parentValue,
    focus,
    setSelection,
    getSelection,
    refetchWith,
    dispatch,
    DOM_ID,
    is_mounted,
    prev_value,
    prev_options,
    prev_parent_value,
    currentValueField,
    currentLabelField,
    selectedOptions,
    selectedKeys,
    alreadyCreated,
    is_focused,
    focus_by_mouse,
    is_tainted,
    is_dropdown_opened,
    dropdown_show,
    dropdown_index,
    render_dropdown,
    dropdown_scroller,
    virtuallist_automode,
    vl_height,
    vl_itemSize,
    meta_key,
    hasEmptyList,
    input_value,
    disable_key_event_bubble,
    i18n_actual,
    fetch_initOnly,
    fetch_initValue,
    isIOS,
    isAndroid,
    doCollapse,
    isFetchingData,
    isCreating,
    flipDurationMs,
    is_dragging,
    is_fetch_dependent,
    ref_input,
    ref_select_element,
    ref_container,
    ref_container_scroll,
    ref_virtuallist,
    itemConfig,
    watch_item_props,
    watch_options,
    watch_value_change,
    watch_selectedOptions,
    watch_parentValue,
    watch_options_virtualList,
    watch_is_dropdown_opened,
    watch_i18n,
    watch_listMessage,
    emitChangeEvent,
    emitCreateEvent,
    onSelect,
    onSelectTeardown,
    selectOption,
    onDeselect,
    deselectOption,
    clearSelection,
    onCreate,
    processKeyDown,
    onMouseDown,
    onClick,
    onKeyDown,
    onKeyUp,
    onInput,
    onFocus,
    onBlur,
    onPaste,
    onDndEvent,
    fetch_controller,
    debouncedFetch,
    listMessage,
    watch_fetch_init,
    fetch_store,
    fetch_reset,
    trigger_fetch,
    fetch_runner,
    resolveExcludedValue,
    setDropdownIndex,
    focusControl,
    get_dropdown_dimensions,
    svelte_use_form_validator,
    options_filtered,
    maxReached,
    enter_hint,
    options_flat,
    itemRenderer,
    aria_context,
    aria_selection,
    placeholder_active,
    input_mode,
    vl_listHeight
  });
  $$self.$inject_state = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("inputId" in $$props2)
      $$invalidate(2, inputId = $$props2.inputId);
    if ("required" in $$props2)
      $$invalidate(5, required = $$props2.required);
    if ("disabled" in $$props2)
      $$invalidate(3, disabled = $$props2.disabled);
    if ("anchor_element" in $$props2)
      $$invalidate(6, anchor_element = $$props2.anchor_element);
    if ("options" in $$props2)
      $$invalidate(60, options = $$props2.options);
    if ("optionResolver" in $$props2)
      $$invalidate(65, optionResolver = $$props2.optionResolver);
    if ("valueField" in $$props2)
      $$invalidate(66, valueField = $$props2.valueField);
    if ("labelField" in $$props2)
      $$invalidate(67, labelField = $$props2.labelField);
    if ("groupLabelField" in $$props2)
      $$invalidate(68, groupLabelField = $$props2.groupLabelField);
    if ("groupItemsField" in $$props2)
      $$invalidate(69, groupItemsField = $$props2.groupItemsField);
    if ("disabledField" in $$props2)
      $$invalidate(7, disabledField = $$props2.disabledField);
    if ("placeholder" in $$props2)
      $$invalidate(70, placeholder = $$props2.placeholder);
    if ("searchable" in $$props2)
      $$invalidate(8, searchable = $$props2.searchable);
    if ("clearable" in $$props2)
      $$invalidate(9, clearable = $$props2.clearable);
    if ("renderer" in $$props2)
      $$invalidate(71, renderer = $$props2.renderer);
    if ("disableHighlight" in $$props2)
      $$invalidate(10, disableHighlight = $$props2.disableHighlight);
    if ("highlightFirstItem" in $$props2)
      $$invalidate(72, highlightFirstItem = $$props2.highlightFirstItem);
    if ("selectOnTab" in $$props2)
      $$invalidate(73, selectOnTab = $$props2.selectOnTab);
    if ("resetOnBlur" in $$props2)
      $$invalidate(11, resetOnBlur = $$props2.resetOnBlur);
    if ("resetOnSelect" in $$props2)
      $$invalidate(74, resetOnSelect = $$props2.resetOnSelect);
    if ("closeAfterSelect" in $$props2)
      $$invalidate(75, closeAfterSelect = $$props2.closeAfterSelect);
    if ("dndzone" in $$props2)
      $$invalidate(12, dndzone = $$props2.dndzone);
    if ("validatorAction" in $$props2)
      $$invalidate(13, validatorAction = $$props2.validatorAction);
    if ("strictMode" in $$props2)
      $$invalidate(76, strictMode = $$props2.strictMode);
    if ("multiple" in $$props2)
      $$invalidate(0, multiple = $$props2.multiple);
    if ("max" in $$props2)
      $$invalidate(77, max = $$props2.max);
    if ("collapseSelection" in $$props2)
      $$invalidate(78, collapseSelection = $$props2.collapseSelection);
    if ("keepSelectionInList" in $$props2)
      $$invalidate(79, keepSelectionInList = $$props2.keepSelectionInList);
    if ("creatable" in $$props2)
      $$invalidate(14, creatable = $$props2.creatable);
    if ("creatablePrefix" in $$props2)
      $$invalidate(80, creatablePrefix = $$props2.creatablePrefix);
    if ("allowEditing" in $$props2)
      $$invalidate(81, allowEditing = $$props2.allowEditing);
    if ("keepCreated" in $$props2)
      $$invalidate(82, keepCreated = $$props2.keepCreated);
    if ("delimiter" in $$props2)
      $$invalidate(83, delimiter = $$props2.delimiter);
    if ("createFilter" in $$props2)
      $$invalidate(1, createFilter = $$props2.createFilter);
    if ("createHandler" in $$props2)
      $$invalidate(61, createHandler = $$props2.createHandler);
    if ("fetch" in $$props2)
      $$invalidate(84, fetch = $$props2.fetch);
    if ("fetchProps" in $$props2)
      $$invalidate(85, fetchProps = $$props2.fetchProps);
    if ("fetchMode" in $$props2)
      $$invalidate(86, fetchMode = $$props2.fetchMode);
    if ("fetchCallback" in $$props2)
      $$invalidate(87, fetchCallback = $$props2.fetchCallback);
    if ("fetchResetOnBlur" in $$props2)
      $$invalidate(63, fetchResetOnBlur = $$props2.fetchResetOnBlur);
    if ("fetchDebounceTime" in $$props2)
      $$invalidate(88, fetchDebounceTime = $$props2.fetchDebounceTime);
    if ("minQuery" in $$props2)
      $$invalidate(89, minQuery = $$props2.minQuery);
    if ("lazyDropdown" in $$props2)
      $$invalidate(90, lazyDropdown = $$props2.lazyDropdown);
    if ("virtualList" in $$props2)
      $$invalidate(15, virtualList = $$props2.virtualList);
    if ("vlHeight" in $$props2)
      $$invalidate(91, vlHeight = $$props2.vlHeight);
    if ("vlItemSize" in $$props2)
      $$invalidate(92, vlItemSize = $$props2.vlItemSize);
    if ("searchProps" in $$props2)
      $$invalidate(93, searchProps = $$props2.searchProps);
    if ("className" in $$props2)
      $$invalidate(16, className = $$props2.className);
    if ("i18n" in $$props2)
      $$invalidate(94, i18n = $$props2.i18n);
    if ("readSelection" in $$props2)
      $$invalidate(64, readSelection = $$props2.readSelection);
    if ("value" in $$props2)
      $$invalidate(62, value = $$props2.value);
    if ("valueAsObject" in $$props2)
      $$invalidate(95, valueAsObject = $$props2.valueAsObject);
    if ("parentValue" in $$props2)
      $$invalidate(96, parentValue = $$props2.parentValue);
    if ("is_mounted" in $$props2)
      $$invalidate(17, is_mounted = $$props2.is_mounted);
    if ("prev_value" in $$props2)
      prev_value = $$props2.prev_value;
    if ("prev_options" in $$props2)
      $$invalidate(101, prev_options = $$props2.prev_options);
    if ("prev_parent_value" in $$props2)
      prev_parent_value = $$props2.prev_parent_value;
    if ("currentValueField" in $$props2)
      $$invalidate(26, currentValueField = $$props2.currentValueField);
    if ("currentLabelField" in $$props2)
      $$invalidate(102, currentLabelField = $$props2.currentLabelField);
    if ("selectedOptions" in $$props2)
      $$invalidate(18, selectedOptions = $$props2.selectedOptions);
    if ("alreadyCreated" in $$props2)
      $$invalidate(103, alreadyCreated = $$props2.alreadyCreated);
    if ("is_focused" in $$props2)
      $$invalidate(27, is_focused = $$props2.is_focused);
    if ("focus_by_mouse" in $$props2)
      focus_by_mouse = $$props2.focus_by_mouse;
    if ("is_tainted" in $$props2)
      $$invalidate(28, is_tainted = $$props2.is_tainted);
    if ("is_dropdown_opened" in $$props2)
      $$invalidate(19, is_dropdown_opened = $$props2.is_dropdown_opened);
    if ("dropdown_show" in $$props2)
      $$invalidate(29, dropdown_show = $$props2.dropdown_show);
    if ("dropdown_index" in $$props2)
      $$invalidate(20, dropdown_index = $$props2.dropdown_index);
    if ("render_dropdown" in $$props2)
      $$invalidate(30, render_dropdown = $$props2.render_dropdown);
    if ("dropdown_scroller" in $$props2)
      dropdown_scroller = $$props2.dropdown_scroller;
    if ("virtuallist_automode" in $$props2)
      $$invalidate(131, virtuallist_automode = $$props2.virtuallist_automode);
    if ("vl_height" in $$props2)
      $$invalidate(104, vl_height = $$props2.vl_height);
    if ("vl_itemSize" in $$props2)
      $$invalidate(21, vl_itemSize = $$props2.vl_itemSize);
    if ("meta_key" in $$props2)
      $$invalidate(31, meta_key = $$props2.meta_key);
    if ("hasEmptyList" in $$props2)
      hasEmptyList = $$props2.hasEmptyList;
    if ("input_value" in $$props2)
      $$invalidate(22, input_value = $$props2.input_value);
    if ("disable_key_event_bubble" in $$props2)
      disable_key_event_bubble = $$props2.disable_key_event_bubble;
    if ("i18n_actual" in $$props2)
      $$invalidate(23, i18n_actual = $$props2.i18n_actual);
    if ("fetch_initOnly" in $$props2)
      fetch_initOnly = $$props2.fetch_initOnly;
    if ("fetch_initValue" in $$props2)
      fetch_initValue = $$props2.fetch_initValue;
    if ("isIOS" in $$props2)
      isIOS = $$props2.isIOS;
    if ("isAndroid" in $$props2)
      isAndroid = $$props2.isAndroid;
    if ("doCollapse" in $$props2)
      $$invalidate(32, doCollapse = $$props2.doCollapse);
    if ("isFetchingData" in $$props2)
      $$invalidate(33, isFetchingData = $$props2.isFetchingData);
    if ("isCreating" in $$props2)
      $$invalidate(34, isCreating = $$props2.isCreating);
    if ("flipDurationMs" in $$props2)
      $$invalidate(35, flipDurationMs = $$props2.flipDurationMs);
    if ("is_dragging" in $$props2)
      is_dragging = $$props2.is_dragging;
    if ("is_fetch_dependent" in $$props2)
      is_fetch_dependent = $$props2.is_fetch_dependent;
    if ("ref_input" in $$props2)
      $$invalidate(36, ref_input = $$props2.ref_input);
    if ("ref_select_element" in $$props2)
      $$invalidate(37, ref_select_element = $$props2.ref_select_element);
    if ("ref_container" in $$props2)
      $$invalidate(38, ref_container = $$props2.ref_container);
    if ("ref_container_scroll" in $$props2)
      $$invalidate(39, ref_container_scroll = $$props2.ref_container_scroll);
    if ("ref_virtuallist" in $$props2)
      $$invalidate(40, ref_virtuallist = $$props2.ref_virtuallist);
    if ("fetch_controller" in $$props2)
      fetch_controller = $$props2.fetch_controller;
    if ("debouncedFetch" in $$props2)
      debouncedFetch = $$props2.debouncedFetch;
    if ("listMessage" in $$props2)
      $$invalidate(41, listMessage = $$props2.listMessage);
    if ("fetch_store" in $$props2)
      fetch_store = $$props2.fetch_store;
    if ("options_filtered" in $$props2)
      $$invalidate(24, options_filtered = $$props2.options_filtered);
    if ("maxReached" in $$props2)
      $$invalidate(25, maxReached = $$props2.maxReached);
    if ("enter_hint" in $$props2)
      $$invalidate(42, enter_hint = $$props2.enter_hint);
    if ("options_flat" in $$props2)
      $$invalidate(106, options_flat = $$props2.options_flat);
    if ("itemRenderer" in $$props2)
      $$invalidate(43, itemRenderer = $$props2.itemRenderer);
    if ("aria_context" in $$props2)
      $$invalidate(44, aria_context = $$props2.aria_context);
    if ("aria_selection" in $$props2)
      $$invalidate(45, aria_selection = $$props2.aria_selection);
    if ("placeholder_active" in $$props2)
      $$invalidate(46, placeholder_active = $$props2.placeholder_active);
    if ("input_mode" in $$props2)
      $$invalidate(47, input_mode = $$props2.input_mode);
    if ("vl_listHeight" in $$props2)
      $$invalidate(48, vl_listHeight = $$props2.vl_listHeight);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[2] & /*valueField, labelField*/
    48) {
      $:
        watch_item_props(valueField, labelField);
    }
    if ($$self.$$.dirty[0] & /*selectedOptions*/
    262144 | $$self.$$.dirty[2] & /*max*/
    32768) {
      $:
        $$invalidate(25, maxReached = max !== 0 && selectedOptions.length == max);
    }
    if ($$self.$$.dirty[1] & /*options*/
    536870912) {
      $:
        watch_options(options);
    }
    if ($$self.$$.dirty[3] & /*prev_options, itemConfig*/
    4352) {
      $:
        $$invalidate(106, options_flat = flatList(prev_options, itemConfig));
    }
    if ($$self.$$.dirty[2] & /*value*/
    1) {
      $:
        watch_value_change(value);
    }
    if ($$self.$$.dirty[0] & /*maxReached, input_value*/
    37748736 | $$self.$$.dirty[3] & /*options_flat, itemConfig, searchProps*/
    12289) {
      $:
        $$invalidate(24, options_filtered = maxReached ? [] : filterList(options_flat, input_value, resolveExcludedValue(input_value), itemConfig, searchProps || {}));
    }
    if ($$self.$$.dirty[2] & /*highlightFirstItem*/
    1024) {
      $:
        highlightFirstItem && setDropdownIndex(0, { asc: true });
    }
    if ($$self.$$.dirty[0] & /*options_filtered, dropdown_index, creatable*/
    17842176) {
      $:
        options_filtered.length <= dropdown_index && setDropdownIndex(0, { asc: !creatable, desc: creatable });
    }
    if ($$self.$$.dirty[0] & /*createFilter*/
    2 | $$self.$$.dirty[3] & /*alreadyCreated*/
    1024) {
      $:
        if (!createFilter)
          $$invalidate(1, createFilter = (inputVal) => alreadyCreated.includes(inputVal));
    }
    if ($$self.$$.dirty[1] & /*createHandler*/
    1073741824) {
      $:
        if (!createHandler)
          $$invalidate(61, createHandler = ({ inputValue, labelField: labelField2, valueField: valueField2, prefix }) => ({
            [valueField2]: inputValue,
            [labelField2]: `${prefix}${inputValue}`
          }));
    }
    if ($$self.$$.dirty[3] & /*i18n*/
    2) {
      $:
        watch_i18n(i18n);
    }
    if ($$self.$$.dirty[3] & /*parentValue*/
    8) {
      $:
        watch_parentValue(parentValue);
    }
    if ($$self.$$.dirty[0] & /*selectedOptions*/
    262144) {
      $:
        watch_selectedOptions(selectedOptions);
    }
    if ($$self.$$.dirty[2] & /*renderer*/
    512 | $$self.$$.dirty[3] & /*currentLabelField*/
    512) {
      $:
        $$invalidate(43, itemRenderer = typeof renderer === "function" ? renderer : stringFormatters[renderer] || stringFormatters.default.bind({ label: currentLabelField }));
    }
    if ($$self.$$.dirty[0] & /*vl_itemSize, options_filtered*/
    18874368 | $$self.$$.dirty[3] & /*vl_height*/
    2048) {
      $:
        $$invalidate(48, vl_listHeight = Math.min(vl_height, Array.isArray(vl_itemSize) ? vl_itemSize.reduce(
          (res, num) => {
            res += num;
            return res;
          },
          0
        ) : options_filtered.length * vl_itemSize));
    }
    if ($$self.$$.dirty[0] & /*options_filtered*/
    16777216) {
      $:
        virtuallist_automode && watch_options_virtualList(options_filtered);
    }
    if ($$self.$$.dirty[0] & /*is_dropdown_opened*/
    524288) {
      $:
        watch_is_dropdown_opened(is_dropdown_opened);
    }
    if ($$self.$$.dirty[0] & /*searchable*/
    256) {
      $:
        $$invalidate(47, input_mode = searchable ? "text" : "none");
    }
    if ($$self.$$.dirty[0] & /*selectedOptions*/
    262144 | $$self.$$.dirty[2] & /*placeholder*/
    256) {
      $:
        $$invalidate(46, placeholder_active = selectedOptions.length ? "" : placeholder);
    }
    if ($$self.$$.dirty[0] & /*selectedOptions, multiple*/
    262145) {
      $:
        $$invalidate(42, enter_hint = selectedOptions.length > 0 && multiple === false ? null : "enter");
    }
    if ($$self.$$.dirty[0] & /*i18n_actual, selectedOptions*/
    8650752 | $$self.$$.dirty[3] & /*currentLabelField*/
    512) {
      $:
        $$invalidate(45, aria_selection = i18n_actual.aria_selected(selectedOptions.map((o) => o[currentLabelField])));
    }
    if ($$self.$$.dirty[0] & /*options_filtered, dropdown_index, is_dropdown_opened, i18n_actual, input_value*/
    30932992 | $$self.$$.dirty[3] & /*currentLabelField*/
    512) {
      $:
        $$invalidate(44, aria_context = options_filtered.length && dropdown_index ? is_dropdown_opened ? i18n_actual.aria_listActive(options_filtered[dropdown_index], currentLabelField, options_filtered.length) : i18n_actual.aria_inputFocused() : input_value.length ? i18n_actual.nomatch : i18n_actual.empty);
    }
    if ($$self.$$.dirty[0] & /*input_value*/
    4194304) {
      $:
        trigger_fetch(input_value);
    }
    if ($$self.$$.dirty[0] & /*is_mounted*/
    131072 | $$self.$$.dirty[2] & /*fetch*/
    4194304 | $$self.$$.dirty[3] & /*parentValue*/
    8) {
      $:
        is_mounted && watch_fetch_init(fetch, parentValue);
    }
    if ($$self.$$.dirty[0] & /*maxReached, options_filtered*/
    50331648) {
      $:
        watch_listMessage(maxReached, options_filtered);
    }
  };
  return [
    multiple,
    createFilter,
    inputId,
    disabled,
    name,
    required,
    anchor_element,
    disabledField,
    searchable,
    clearable,
    disableHighlight,
    resetOnBlur,
    dndzone,
    validatorAction,
    creatable,
    virtualList,
    className,
    is_mounted,
    selectedOptions,
    is_dropdown_opened,
    dropdown_index,
    vl_itemSize,
    input_value,
    i18n_actual,
    options_filtered,
    maxReached,
    currentValueField,
    is_focused,
    is_tainted,
    dropdown_show,
    render_dropdown,
    meta_key,
    doCollapse,
    isFetchingData,
    isCreating,
    flipDurationMs,
    ref_input,
    ref_select_element,
    ref_container,
    ref_container_scroll,
    ref_virtuallist,
    listMessage,
    enter_hint,
    itemRenderer,
    aria_context,
    aria_selection,
    placeholder_active,
    input_mode,
    vl_listHeight,
    DOM_ID,
    onCreate,
    onClick,
    onKeyDown,
    onKeyUp,
    onInput,
    onFocus,
    onBlur,
    onPaste,
    onDndEvent,
    svelte_use_form_validator,
    options,
    createHandler,
    value,
    fetchResetOnBlur,
    readSelection,
    optionResolver,
    valueField,
    labelField,
    groupLabelField,
    groupItemsField,
    placeholder,
    renderer,
    highlightFirstItem,
    selectOnTab,
    resetOnSelect,
    closeAfterSelect,
    strictMode,
    max,
    collapseSelection,
    keepSelectionInList,
    creatablePrefix,
    allowEditing,
    keepCreated,
    delimiter,
    fetch,
    fetchProps,
    fetchMode,
    fetchCallback,
    fetchDebounceTime,
    minQuery,
    lazyDropdown,
    vlHeight,
    vlItemSize,
    searchProps,
    i18n,
    valueAsObject,
    parentValue,
    focus,
    setSelection,
    getSelection,
    refetchWith,
    prev_options,
    currentLabelField,
    alreadyCreated,
    vl_height,
    itemConfig,
    options_flat,
    slots,
    mousedown_handler_1,
    mousedown_handler,
    select_binding,
    input_binding,
    input_input_handler,
    tinyvirtuallist_binding,
    div0_binding,
    div1_binding,
    $$scope
  ];
}
var Svelecte = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        name: 4,
        inputId: 2,
        required: 5,
        disabled: 3,
        anchor_element: 6,
        options: 60,
        optionResolver: 65,
        valueField: 66,
        labelField: 67,
        groupLabelField: 68,
        groupItemsField: 69,
        disabledField: 7,
        placeholder: 70,
        searchable: 8,
        clearable: 9,
        renderer: 71,
        disableHighlight: 10,
        highlightFirstItem: 72,
        selectOnTab: 73,
        resetOnBlur: 11,
        resetOnSelect: 74,
        closeAfterSelect: 75,
        dndzone: 12,
        validatorAction: 13,
        strictMode: 76,
        multiple: 0,
        max: 77,
        collapseSelection: 78,
        keepSelectionInList: 79,
        creatable: 14,
        creatablePrefix: 80,
        allowEditing: 81,
        keepCreated: 82,
        delimiter: 83,
        createFilter: 1,
        createHandler: 61,
        fetch: 84,
        fetchProps: 85,
        fetchMode: 86,
        fetchCallback: 87,
        fetchResetOnBlur: 63,
        fetchDebounceTime: 88,
        minQuery: 89,
        lazyDropdown: 90,
        virtualList: 15,
        vlHeight: 91,
        vlItemSize: 92,
        searchProps: 93,
        class: 16,
        i18n: 94,
        readSelection: 64,
        value: 62,
        valueAsObject: 95,
        parentValue: 96,
        focus: 97,
        setSelection: 98,
        getSelection: 99,
        refetchWith: 100
      },
      add_css2,
      [-1, -1, -1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Svelecte",
      options,
      id: create_fragment2.name
    });
  }
  get name() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor_element() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor_element(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get optionResolver() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set optionResolver(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueField() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueField(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get labelField() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set labelField(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupLabelField() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupLabelField(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get groupItemsField() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set groupItemsField(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabledField() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabledField(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchable() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchable(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clearable() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clearable(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get renderer() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set renderer(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disableHighlight() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disableHighlight(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get highlightFirstItem() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set highlightFirstItem(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectOnTab() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectOnTab(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resetOnBlur() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resetOnBlur(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resetOnSelect() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resetOnSelect(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeAfterSelect() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeAfterSelect(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dndzone() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dndzone(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validatorAction() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validatorAction(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get strictMode() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set strictMode(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get multiple() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set multiple(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapseSelection() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collapseSelection(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keepSelectionInList() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keepSelectionInList(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get creatable() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set creatable(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get creatablePrefix() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set creatablePrefix(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get allowEditing() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allowEditing(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keepCreated() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keepCreated(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get delimiter() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set delimiter(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get createFilter() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set createFilter(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get createHandler() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set createHandler(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fetch() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fetch(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fetchProps() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fetchProps(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fetchMode() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fetchMode(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fetchCallback() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fetchCallback(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fetchResetOnBlur() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fetchResetOnBlur(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fetchDebounceTime() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fetchDebounceTime(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minQuery() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minQuery(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lazyDropdown() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lazyDropdown(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get virtualList() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set virtualList(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vlHeight() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vlHeight(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vlItemSize() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vlItemSize(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get searchProps() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set searchProps(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get i18n() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set i18n(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get readSelection() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set readSelection(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueAsObject() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueAsObject(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get parentValue() {
    throw new Error("<Svelecte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set parentValue(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[97];
  }
  set focus(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setSelection() {
    return this.$$.ctx[98];
  }
  set setSelection(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSelection() {
    return this.$$.ctx[99];
  }
  set getSelection(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refetchWith() {
    return this.$$.ctx[100];
  }
  set refetchWith(value) {
    throw new Error("<Svelecte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Svelecte_default = Svelecte;

// node_modules/.pnpm/svelecte@4.0.1_svelte@4.2.15/node_modules/svelecte/dist/index.js
var dist_default = Svelecte_default;
export {
  addRenderer,
  config,
  dist_default as default
};
//# sourceMappingURL=svelecte.js.map
